{
"version":3,
"file":"module$node_modules$raw_body$index.js",
"lineCount":7,
"mappings":"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",
"sources":["node_modules/raw-body/index.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$raw_body$index\"] = function(global,require,module,exports) {\nvar process = require('process');\nvar Buffer = require('buffer').Buffer;\n/*!\n * raw-body\n * Copyright(c) 2013-2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar bytes = require('bytes')\nvar createError = require('http-errors')\nvar iconv = require('iconv-lite')\nvar unpipe = require('unpipe')\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = getRawBody\n\n/**\n * Module variables.\n * @private\n */\n\nvar ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /\n\n/**\n * Get the decoder for a given encoding.\n *\n * @param {string} encoding\n * @private\n */\n\nfunction getDecoder (encoding) {\n  if (!encoding) return null\n\n  try {\n    return iconv.getDecoder(encoding)\n  } catch (e) {\n    // error getting decoder\n    if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e\n\n    // the encoding was not found\n    throw createError(415, 'specified encoding unsupported', {\n      encoding: encoding,\n      type: 'encoding.unsupported'\n    })\n  }\n}\n\n/**\n * Get the raw body of a stream (typically HTTP).\n *\n * @param {object} stream\n * @param {object|string|function} [options]\n * @param {function} [callback]\n * @public\n */\n\nfunction getRawBody (stream, options, callback) {\n  var done = callback\n  var opts = options || {}\n\n  if (options === true || typeof options === 'string') {\n    // short cut for encoding\n    opts = {\n      encoding: options\n    }\n  }\n\n  if (typeof options === 'function') {\n    done = options\n    opts = {}\n  }\n\n  // validate callback is a function, if provided\n  if (done !== undefined && typeof done !== 'function') {\n    throw new TypeError('argument callback must be a function')\n  }\n\n  // require the callback without promises\n  if (!done && !global.Promise) {\n    throw new TypeError('argument callback is required')\n  }\n\n  // get encoding\n  var encoding = opts.encoding !== true\n    ? opts.encoding\n    : 'utf-8'\n\n  // convert the limit to an integer\n  var limit = bytes.parse(opts.limit)\n\n  // convert the expected length to an integer\n  var length = opts.length != null && !isNaN(opts.length)\n    ? parseInt(opts.length, 10)\n    : null\n\n  if (done) {\n    // classic callback style\n    return readStream(stream, encoding, length, limit, done)\n  }\n\n  return new Promise(function executor (resolve, reject) {\n    readStream(stream, encoding, length, limit, function onRead (err, buf) {\n      if (err) return reject(err)\n      resolve(buf)\n    })\n  })\n}\n\n/**\n * Halt a stream.\n *\n * @param {Object} stream\n * @private\n */\n\nfunction halt (stream) {\n  // unpipe everything from the stream\n  unpipe(stream)\n\n  // pause stream\n  if (typeof stream.pause === 'function') {\n    stream.pause()\n  }\n}\n\n/**\n * Read the data from the stream.\n *\n * @param {object} stream\n * @param {string} encoding\n * @param {number} length\n * @param {number} limit\n * @param {function} callback\n * @public\n */\n\nfunction readStream (stream, encoding, length, limit, callback) {\n  var complete = false\n  var sync = true\n\n  // check the length and limit options.\n  // note: we intentionally leave the stream paused,\n  // so users should handle the stream themselves.\n  if (limit !== null && length !== null && length > limit) {\n    return done(createError(413, 'request entity too large', {\n      expected: length,\n      length: length,\n      limit: limit,\n      type: 'entity.too.large'\n    }))\n  }\n\n  // streams1: assert request encoding is buffer.\n  // streams2+: assert the stream encoding is buffer.\n  //   stream._decoder: streams1\n  //   state.encoding: streams2\n  //   state.decoder: streams2, specifically < 0.10.6\n  var state = stream._readableState\n  if (stream._decoder || (state && (state.encoding || state.decoder))) {\n    // developer error\n    return done(createError(500, 'stream encoding should not be set', {\n      type: 'stream.encoding.set'\n    }))\n  }\n\n  var received = 0\n  var decoder\n\n  try {\n    decoder = getDecoder(encoding)\n  } catch (err) {\n    return done(err)\n  }\n\n  var buffer = decoder\n    ? ''\n    : []\n\n  // attach listeners\n  stream.on('aborted', onAborted)\n  stream.on('close', cleanup)\n  stream.on('data', onData)\n  stream.on('end', onEnd)\n  stream.on('error', onEnd)\n\n  // mark sync section complete\n  sync = false\n\n  function done () {\n    var args = new Array(arguments.length)\n\n    // copy arguments\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n\n    // mark complete\n    complete = true\n\n    if (sync) {\n      process.nextTick(invokeCallback)\n    } else {\n      invokeCallback()\n    }\n\n    function invokeCallback () {\n      cleanup()\n\n      if (args[0]) {\n        // halt the stream on error\n        halt(stream)\n      }\n\n      callback.apply(null, args)\n    }\n  }\n\n  function onAborted () {\n    if (complete) return\n\n    done(createError(400, 'request aborted', {\n      code: 'ECONNABORTED',\n      expected: length,\n      length: length,\n      received: received,\n      type: 'request.aborted'\n    }))\n  }\n\n  function onData (chunk) {\n    if (complete) return\n\n    received += chunk.length\n\n    if (limit !== null && received > limit) {\n      done(createError(413, 'request entity too large', {\n        limit: limit,\n        received: received,\n        type: 'entity.too.large'\n      }))\n    } else if (decoder) {\n      buffer += decoder.write(chunk)\n    } else {\n      buffer.push(chunk)\n    }\n  }\n\n  function onEnd (err) {\n    if (complete) return\n    if (err) return done(err)\n\n    if (length !== null && received !== length) {\n      done(createError(400, 'request size did not match content length', {\n        expected: length,\n        length: length,\n        received: received,\n        type: 'request.size.invalid'\n      }))\n    } else {\n      var string = decoder\n        ? buffer + (decoder.end() || '')\n        : Buffer.concat(buffer)\n      done(null, string)\n    }\n  }\n\n  function cleanup () {\n    buffer = null\n\n    stream.removeListener('aborted', onAborted)\n    stream.removeListener('data', onData)\n    stream.removeListener('end', onEnd)\n    stream.removeListener('error', onEnd)\n    stream.removeListener('close', cleanup)\n  }\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","getDecoder","encoding","iconv","e","ICONV_ENCODING_MESSAGE_REGEXP","test","message","createError","type","readStream","stream","length","limit","callback","done","invokeCallback","cleanup","args","unpipe","pause","apply","Array","arguments","i","complete","sync","process","nextTick","onAborted","code","expected","received","onData","chunk","decoder","buffer","write","push","onEnd","err","string","end","Buffer","concat","removeListener","state","_readableState","_decoder","on","bytes","getRawBody","options","opts","undefined","TypeError","Promise","parse","isNaN","parseInt","executor","resolve","reject","onRead","buf"]
}
