shadow$provide.module$node_modules$body_parser$lib$types$raw=function(global,require,module,exports){function typeChecker(type){return function(req){return!!typeis(req,type)}}var bytes=require("module$node_modules$bytes$index"),debug=require("module$node_modules$debug$src$browser")("body-parser:raw"),read=require("module$node_modules$body_parser$lib$read"),typeis=require("module$node_modules$type_is$index");module.exports=function(options){function parse(buf){return buf}options=options||{};var inflate=
!1!==options.inflate,limit="number"!==typeof options.limit?bytes.parse(options.limit||"100kb"):options.limit,type=options.type||"application/octet-stream",verify=options.verify||!1;if(!1!==verify&&"function"!==typeof verify)throw new TypeError("option verify must be function");var shouldParse="function"!==typeof type?typeChecker(type):type;return function(req,res,next){req._body?(debug("body already parsed"),next()):(req.body=req.body||{},typeis.hasBody(req)?(debug("content-type %j",req.headers["content-type"]),
shouldParse(req)?read(req,res,next,parse,debug,{encoding:null,inflate:inflate,limit:limit,verify:verify}):(debug("skip parsing"),next())):(debug("skip empty body"),next()))}}}
//# sourceMappingURL=module$node_modules$body_parser$lib$types$raw.js.map
