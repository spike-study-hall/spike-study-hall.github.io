{
"version":3,
"file":"module$node_modules$browserify_zlib$lib$index.js",
"lineCount":24,
"mappings":"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",
"sources":["node_modules/browserify-zlib/lib/index.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$browserify_zlib$lib$index\"] = function(global,require,module,exports) {\nvar process = require('process');\n'use strict';\n\nvar Buffer = require('buffer').Buffer;\nvar Transform = require('stream').Transform;\nvar binding = require('./binding');\nvar util = require('util');\nvar assert = require('assert').ok;\nvar kMaxLength = require('buffer').kMaxLength;\nvar kRangeErrorMessage = 'Cannot create final Buffer. It would be larger ' + 'than 0x' + kMaxLength.toString(16) + ' bytes';\n\n// zlib doesn't provide these, so kludge them in following the same\n// const naming scheme zlib uses.\nbinding.Z_MIN_WINDOWBITS = 8;\nbinding.Z_MAX_WINDOWBITS = 15;\nbinding.Z_DEFAULT_WINDOWBITS = 15;\n\n// fewer than 64 bytes per chunk is stupid.\n// technically it could work with as few as 8, but even 64 bytes\n// is absurdly low.  Usually a MB or more is best.\nbinding.Z_MIN_CHUNK = 64;\nbinding.Z_MAX_CHUNK = Infinity;\nbinding.Z_DEFAULT_CHUNK = 16 * 1024;\n\nbinding.Z_MIN_MEMLEVEL = 1;\nbinding.Z_MAX_MEMLEVEL = 9;\nbinding.Z_DEFAULT_MEMLEVEL = 8;\n\nbinding.Z_MIN_LEVEL = -1;\nbinding.Z_MAX_LEVEL = 9;\nbinding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;\n\n// expose all the zlib constants\nvar bkeys = Object.keys(binding);\nfor (var bk = 0; bk < bkeys.length; bk++) {\n  var bkey = bkeys[bk];\n  if (bkey.match(/^Z/)) {\n    Object.defineProperty(exports, bkey, {\n      enumerable: true, value: binding[bkey], writable: false\n    });\n  }\n}\n\n// translation table for return codes.\nvar codes = {\n  Z_OK: binding.Z_OK,\n  Z_STREAM_END: binding.Z_STREAM_END,\n  Z_NEED_DICT: binding.Z_NEED_DICT,\n  Z_ERRNO: binding.Z_ERRNO,\n  Z_STREAM_ERROR: binding.Z_STREAM_ERROR,\n  Z_DATA_ERROR: binding.Z_DATA_ERROR,\n  Z_MEM_ERROR: binding.Z_MEM_ERROR,\n  Z_BUF_ERROR: binding.Z_BUF_ERROR,\n  Z_VERSION_ERROR: binding.Z_VERSION_ERROR\n};\n\nvar ckeys = Object.keys(codes);\nfor (var ck = 0; ck < ckeys.length; ck++) {\n  var ckey = ckeys[ck];\n  codes[codes[ckey]] = ckey;\n}\n\nObject.defineProperty(exports, 'codes', {\n  enumerable: true, value: Object.freeze(codes), writable: false\n});\n\nexports.Deflate = Deflate;\nexports.Inflate = Inflate;\nexports.Gzip = Gzip;\nexports.Gunzip = Gunzip;\nexports.DeflateRaw = DeflateRaw;\nexports.InflateRaw = InflateRaw;\nexports.Unzip = Unzip;\n\nexports.createDeflate = function (o) {\n  return new Deflate(o);\n};\n\nexports.createInflate = function (o) {\n  return new Inflate(o);\n};\n\nexports.createDeflateRaw = function (o) {\n  return new DeflateRaw(o);\n};\n\nexports.createInflateRaw = function (o) {\n  return new InflateRaw(o);\n};\n\nexports.createGzip = function (o) {\n  return new Gzip(o);\n};\n\nexports.createGunzip = function (o) {\n  return new Gunzip(o);\n};\n\nexports.createUnzip = function (o) {\n  return new Unzip(o);\n};\n\n// Convenience methods.\n// compress/decompress a string or buffer in one step.\nexports.deflate = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Deflate(opts), buffer, callback);\n};\n\nexports.deflateSync = function (buffer, opts) {\n  return zlibBufferSync(new Deflate(opts), buffer);\n};\n\nexports.gzip = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Gzip(opts), buffer, callback);\n};\n\nexports.gzipSync = function (buffer, opts) {\n  return zlibBufferSync(new Gzip(opts), buffer);\n};\n\nexports.deflateRaw = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new DeflateRaw(opts), buffer, callback);\n};\n\nexports.deflateRawSync = function (buffer, opts) {\n  return zlibBufferSync(new DeflateRaw(opts), buffer);\n};\n\nexports.unzip = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Unzip(opts), buffer, callback);\n};\n\nexports.unzipSync = function (buffer, opts) {\n  return zlibBufferSync(new Unzip(opts), buffer);\n};\n\nexports.inflate = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Inflate(opts), buffer, callback);\n};\n\nexports.inflateSync = function (buffer, opts) {\n  return zlibBufferSync(new Inflate(opts), buffer);\n};\n\nexports.gunzip = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Gunzip(opts), buffer, callback);\n};\n\nexports.gunzipSync = function (buffer, opts) {\n  return zlibBufferSync(new Gunzip(opts), buffer);\n};\n\nexports.inflateRaw = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new InflateRaw(opts), buffer, callback);\n};\n\nexports.inflateRawSync = function (buffer, opts) {\n  return zlibBufferSync(new InflateRaw(opts), buffer);\n};\n\nfunction zlibBuffer(engine, buffer, callback) {\n  var buffers = [];\n  var nread = 0;\n\n  engine.on('error', onError);\n  engine.on('end', onEnd);\n\n  engine.end(buffer);\n  flow();\n\n  function flow() {\n    var chunk;\n    while (null !== (chunk = engine.read())) {\n      buffers.push(chunk);\n      nread += chunk.length;\n    }\n    engine.once('readable', flow);\n  }\n\n  function onError(err) {\n    engine.removeListener('end', onEnd);\n    engine.removeListener('readable', flow);\n    callback(err);\n  }\n\n  function onEnd() {\n    var buf;\n    var err = null;\n\n    if (nread >= kMaxLength) {\n      err = new RangeError(kRangeErrorMessage);\n    } else {\n      buf = Buffer.concat(buffers, nread);\n    }\n\n    buffers = [];\n    engine.close();\n    callback(err, buf);\n  }\n}\n\nfunction zlibBufferSync(engine, buffer) {\n  if (typeof buffer === 'string') buffer = Buffer.from(buffer);\n\n  if (!Buffer.isBuffer(buffer)) throw new TypeError('Not a string or buffer');\n\n  var flushFlag = engine._finishFlushFlag;\n\n  return engine._processChunk(buffer, flushFlag);\n}\n\n// generic zlib\n// minimal 2-byte header\nfunction Deflate(opts) {\n  if (!(this instanceof Deflate)) return new Deflate(opts);\n  Zlib.call(this, opts, binding.DEFLATE);\n}\n\nfunction Inflate(opts) {\n  if (!(this instanceof Inflate)) return new Inflate(opts);\n  Zlib.call(this, opts, binding.INFLATE);\n}\n\n// gzip - bigger header, same deflate compression\nfunction Gzip(opts) {\n  if (!(this instanceof Gzip)) return new Gzip(opts);\n  Zlib.call(this, opts, binding.GZIP);\n}\n\nfunction Gunzip(opts) {\n  if (!(this instanceof Gunzip)) return new Gunzip(opts);\n  Zlib.call(this, opts, binding.GUNZIP);\n}\n\n// raw - no header\nfunction DeflateRaw(opts) {\n  if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);\n  Zlib.call(this, opts, binding.DEFLATERAW);\n}\n\nfunction InflateRaw(opts) {\n  if (!(this instanceof InflateRaw)) return new InflateRaw(opts);\n  Zlib.call(this, opts, binding.INFLATERAW);\n}\n\n// auto-detect header.\nfunction Unzip(opts) {\n  if (!(this instanceof Unzip)) return new Unzip(opts);\n  Zlib.call(this, opts, binding.UNZIP);\n}\n\nfunction isValidFlushFlag(flag) {\n  return flag === binding.Z_NO_FLUSH || flag === binding.Z_PARTIAL_FLUSH || flag === binding.Z_SYNC_FLUSH || flag === binding.Z_FULL_FLUSH || flag === binding.Z_FINISH || flag === binding.Z_BLOCK;\n}\n\n// the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\n\nfunction Zlib(opts, mode) {\n  var _this = this;\n\n  this._opts = opts = opts || {};\n  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;\n\n  Transform.call(this, opts);\n\n  if (opts.flush && !isValidFlushFlag(opts.flush)) {\n    throw new Error('Invalid flush flag: ' + opts.flush);\n  }\n  if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) {\n    throw new Error('Invalid flush flag: ' + opts.finishFlush);\n  }\n\n  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;\n  this._finishFlushFlag = typeof opts.finishFlush !== 'undefined' ? opts.finishFlush : binding.Z_FINISH;\n\n  if (opts.chunkSize) {\n    if (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK) {\n      throw new Error('Invalid chunk size: ' + opts.chunkSize);\n    }\n  }\n\n  if (opts.windowBits) {\n    if (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS) {\n      throw new Error('Invalid windowBits: ' + opts.windowBits);\n    }\n  }\n\n  if (opts.level) {\n    if (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL) {\n      throw new Error('Invalid compression level: ' + opts.level);\n    }\n  }\n\n  if (opts.memLevel) {\n    if (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL) {\n      throw new Error('Invalid memLevel: ' + opts.memLevel);\n    }\n  }\n\n  if (opts.strategy) {\n    if (opts.strategy != exports.Z_FILTERED && opts.strategy != exports.Z_HUFFMAN_ONLY && opts.strategy != exports.Z_RLE && opts.strategy != exports.Z_FIXED && opts.strategy != exports.Z_DEFAULT_STRATEGY) {\n      throw new Error('Invalid strategy: ' + opts.strategy);\n    }\n  }\n\n  if (opts.dictionary) {\n    if (!Buffer.isBuffer(opts.dictionary)) {\n      throw new Error('Invalid dictionary: it should be a Buffer instance');\n    }\n  }\n\n  this._handle = new binding.Zlib(mode);\n\n  var self = this;\n  this._hadError = false;\n  this._handle.onerror = function (message, errno) {\n    // there is no way to cleanly recover.\n    // continuing only obscures problems.\n    _close(self);\n    self._hadError = true;\n\n    var error = new Error(message);\n    error.errno = errno;\n    error.code = exports.codes[errno];\n    self.emit('error', error);\n  };\n\n  var level = exports.Z_DEFAULT_COMPRESSION;\n  if (typeof opts.level === 'number') level = opts.level;\n\n  var strategy = exports.Z_DEFAULT_STRATEGY;\n  if (typeof opts.strategy === 'number') strategy = opts.strategy;\n\n  this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);\n\n  this._buffer = Buffer.allocUnsafe(this._chunkSize);\n  this._offset = 0;\n  this._level = level;\n  this._strategy = strategy;\n\n  this.once('end', this.close);\n\n  Object.defineProperty(this, '_closed', {\n    get: function () {\n      return !_this._handle;\n    },\n    configurable: true,\n    enumerable: true\n  });\n}\n\nutil.inherits(Zlib, Transform);\n\nZlib.prototype.params = function (level, strategy, callback) {\n  if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {\n    throw new RangeError('Invalid compression level: ' + level);\n  }\n  if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {\n    throw new TypeError('Invalid strategy: ' + strategy);\n  }\n\n  if (this._level !== level || this._strategy !== strategy) {\n    var self = this;\n    this.flush(binding.Z_SYNC_FLUSH, function () {\n      assert(self._handle, 'zlib binding closed');\n      self._handle.params(level, strategy);\n      if (!self._hadError) {\n        self._level = level;\n        self._strategy = strategy;\n        if (callback) callback();\n      }\n    });\n  } else {\n    process.nextTick(callback);\n  }\n};\n\nZlib.prototype.reset = function () {\n  assert(this._handle, 'zlib binding closed');\n  return this._handle.reset();\n};\n\n// This is the _flush function called by the transform class,\n// internally, when the last chunk has been written.\nZlib.prototype._flush = function (callback) {\n  this._transform(Buffer.alloc(0), '', callback);\n};\n\nZlib.prototype.flush = function (kind, callback) {\n  var _this2 = this;\n\n  var ws = this._writableState;\n\n  if (typeof kind === 'function' || kind === undefined && !callback) {\n    callback = kind;\n    kind = binding.Z_FULL_FLUSH;\n  }\n\n  if (ws.ended) {\n    if (callback) process.nextTick(callback);\n  } else if (ws.ending) {\n    if (callback) this.once('end', callback);\n  } else if (ws.needDrain) {\n    if (callback) {\n      this.once('drain', function () {\n        return _this2.flush(kind, callback);\n      });\n    }\n  } else {\n    this._flushFlag = kind;\n    this.write(Buffer.alloc(0), '', callback);\n  }\n};\n\nZlib.prototype.close = function (callback) {\n  _close(this, callback);\n  process.nextTick(emitCloseNT, this);\n};\n\nfunction _close(engine, callback) {\n  if (callback) process.nextTick(callback);\n\n  // Caller may invoke .close after a zlib error (which will null _handle).\n  if (!engine._handle) return;\n\n  engine._handle.close();\n  engine._handle = null;\n}\n\nfunction emitCloseNT(self) {\n  self.emit('close');\n}\n\nZlib.prototype._transform = function (chunk, encoding, cb) {\n  var flushFlag;\n  var ws = this._writableState;\n  var ending = ws.ending || ws.ended;\n  var last = ending && (!chunk || ws.length === chunk.length);\n\n  if (chunk !== null && !Buffer.isBuffer(chunk)) return cb(new Error('invalid input'));\n\n  if (!this._handle) return cb(new Error('zlib binding closed'));\n\n  // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag\n  // (or whatever flag was provided using opts.finishFlush).\n  // If it's explicitly flushing at some other time, then we use\n  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression\n  // goodness.\n  if (last) flushFlag = this._finishFlushFlag;else {\n    flushFlag = this._flushFlag;\n    // once we've flushed the last of the queue, stop flushing and\n    // go back to the normal behavior.\n    if (chunk.length >= ws.length) {\n      this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;\n    }\n  }\n\n  this._processChunk(chunk, flushFlag, cb);\n};\n\nZlib.prototype._processChunk = function (chunk, flushFlag, cb) {\n  var availInBefore = chunk && chunk.length;\n  var availOutBefore = this._chunkSize - this._offset;\n  var inOff = 0;\n\n  var self = this;\n\n  var async = typeof cb === 'function';\n\n  if (!async) {\n    var buffers = [];\n    var nread = 0;\n\n    var error;\n    this.on('error', function (er) {\n      error = er;\n    });\n\n    assert(this._handle, 'zlib binding closed');\n    do {\n      var res = this._handle.writeSync(flushFlag, chunk, // in\n      inOff, // in_off\n      availInBefore, // in_len\n      this._buffer, // out\n      this._offset, //out_off\n      availOutBefore); // out_len\n    } while (!this._hadError && callback(res[0], res[1]));\n\n    if (this._hadError) {\n      throw error;\n    }\n\n    if (nread >= kMaxLength) {\n      _close(this);\n      throw new RangeError(kRangeErrorMessage);\n    }\n\n    var buf = Buffer.concat(buffers, nread);\n    _close(this);\n\n    return buf;\n  }\n\n  assert(this._handle, 'zlib binding closed');\n  var req = this._handle.write(flushFlag, chunk, // in\n  inOff, // in_off\n  availInBefore, // in_len\n  this._buffer, // out\n  this._offset, //out_off\n  availOutBefore); // out_len\n\n  req.buffer = chunk;\n  req.callback = callback;\n\n  function callback(availInAfter, availOutAfter) {\n    // When the callback is used in an async write, the callback's\n    // context is the `req` object that was created. The req object\n    // is === this._handle, and that's why it's important to null\n    // out the values after they are done being used. `this._handle`\n    // can stay in memory longer than the callback and buffer are needed.\n    if (this) {\n      this.buffer = null;\n      this.callback = null;\n    }\n\n    if (self._hadError) return;\n\n    var have = availOutBefore - availOutAfter;\n    assert(have >= 0, 'have should not go down');\n\n    if (have > 0) {\n      var out = self._buffer.slice(self._offset, self._offset + have);\n      self._offset += have;\n      // serve some output to the consumer.\n      if (async) {\n        self.push(out);\n      } else {\n        buffers.push(out);\n        nread += out.length;\n      }\n    }\n\n    // exhausted the output buffer, or used all the input create a new one.\n    if (availOutAfter === 0 || self._offset >= self._chunkSize) {\n      availOutBefore = self._chunkSize;\n      self._offset = 0;\n      self._buffer = Buffer.allocUnsafe(self._chunkSize);\n    }\n\n    if (availOutAfter === 0) {\n      // Not actually done.  Need to reprocess.\n      // Also, update the availInBefore to the availInAfter value,\n      // so that if we have to hit it a third (fourth, etc.) time,\n      // it'll have the correct byte counts.\n      inOff += availInBefore - availInAfter;\n      availInBefore = availInAfter;\n\n      if (!async) return true;\n\n      var newReq = self._handle.write(flushFlag, chunk, inOff, availInBefore, self._buffer, self._offset, self._chunkSize);\n      newReq.callback = callback; // this same function\n      newReq.buffer = chunk;\n      return;\n    }\n\n    if (!async) return false;\n\n    // finished with the chunk.\n    cb();\n  }\n};\n\nutil.inherits(Deflate, Zlib);\nutil.inherits(Inflate, Zlib);\nutil.inherits(Gzip, Zlib);\nutil.inherits(Gunzip, Zlib);\nutil.inherits(DeflateRaw, Zlib);\nutil.inherits(InflateRaw, Zlib);\nutil.inherits(Unzip, Zlib);\n};"],
"names":["shadow$provide","global","require","module","exports","zlibBuffer","engine","buffer","callback","flow","chunk","read","buffers","push","nread","length","once","onEnd","buf","err","kMaxLength","RangeError","kRangeErrorMessage","Buffer","concat","close","on","onError","removeListener","end","zlibBufferSync","from","isBuffer","TypeError","_processChunk","_finishFlushFlag","Deflate","opts","Zlib","call","binding","DEFLATE","Inflate","INFLATE","Gzip","GZIP","Gunzip","GUNZIP","DeflateRaw","DEFLATERAW","InflateRaw","INFLATERAW","Unzip","UNZIP","isValidFlushFlag","flag","Z_NO_FLUSH","Z_PARTIAL_FLUSH","Z_SYNC_FLUSH","Z_FULL_FLUSH","Z_FINISH","Z_BLOCK","mode","_this","_opts","_chunkSize","chunkSize","Z_DEFAULT_CHUNK","Transform","flush","Error","finishFlush","_flushFlag","Z_MIN_CHUNK","Z_MAX_CHUNK","windowBits","Z_MIN_WINDOWBITS","Z_MAX_WINDOWBITS","level","Z_MIN_LEVEL","Z_MAX_LEVEL","memLevel","Z_MIN_MEMLEVEL","Z_MAX_MEMLEVEL","strategy","Z_FILTERED","Z_HUFFMAN_ONLY","Z_RLE","Z_FIXED","Z_DEFAULT_STRATEGY","dictionary","_handle","self","_hadError","onerror","this._handle.onerror","message","errno","_close","error","code","codes","emit","Z_DEFAULT_COMPRESSION","init","Z_DEFAULT_WINDOWBITS","Z_DEFAULT_MEMLEVEL","_buffer","allocUnsafe","_offset","_level","_strategy","Object","defineProperty","get","configurable","enumerable","process","nextTick","emitCloseNT","util","assert","ok","toString","Infinity","Z_DEFAULT_LEVEL","bkeys","keys","bk","bkey","match","value","writable","Z_OK","Z_STREAM_END","Z_NEED_DICT","Z_ERRNO","Z_STREAM_ERROR","Z_DATA_ERROR","Z_MEM_ERROR","Z_BUF_ERROR","Z_VERSION_ERROR","ckeys","ck","ckey","freeze","createDeflate","exports.createDeflate","o","createInflate","exports.createInflate","createDeflateRaw","exports.createDeflateRaw","createInflateRaw","exports.createInflateRaw","createGzip","exports.createGzip","createGunzip","exports.createGunzip","createUnzip","exports.createUnzip","deflate","exports.deflate","deflateSync","exports.deflateSync","gzip","exports.gzip","gzipSync","exports.gzipSync","deflateRaw","exports.deflateRaw","deflateRawSync","exports.deflateRawSync","unzip","exports.unzip","unzipSync","exports.unzipSync","inflate","exports.inflate","inflateSync","exports.inflateSync","gunzip","exports.gunzip","gunzipSync","exports.gunzipSync","inflateRaw","exports.inflateRaw","inflateRawSync","exports.inflateRawSync","inherits","prototype","params","Zlib.prototype.params","reset","Zlib.prototype.reset","_flush","Zlib.prototype._flush","_transform","alloc","Zlib.prototype.flush","kind","_this2","ws","_writableState","undefined","ended","ending","needDrain","write","Zlib.prototype.close","Zlib.prototype._transform","encoding","cb","last","flushFlag","Zlib.prototype._processChunk","availInAfter","availOutAfter","have","availOutBefore","out","slice","async","inOff","availInBefore","newReq","er","res","writeSync","req"]
}
