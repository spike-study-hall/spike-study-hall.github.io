{
"version":3,
"file":"module$node_modules$vary$index.js",
"lineCount":3,
"mappings":"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",
"sources":["node_modules/vary/index.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$vary$index\"] = function(global,require,module,exports) {\n/*!\n * vary\n * Copyright(c) 2014-2017 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n */\n\nmodule.exports = vary\nmodule.exports.append = append\n\n/**\n * RegExp to match field-name in RFC 7230 sec 3.2\n *\n * field-name    = token\n * token         = 1*tchar\n * tchar         = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n *               / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n *               / DIGIT / ALPHA\n *               ; any VCHAR, except delimiters\n */\n\nvar FIELD_NAME_REGEXP = /^[!#$%&'*+\\-.^_`|~0-9A-Za-z]+$/\n\n/**\n * Append a field to a vary header.\n *\n * @param {String} header\n * @param {String|Array} field\n * @return {String}\n * @public\n */\n\nfunction append (header, field) {\n  if (typeof header !== 'string') {\n    throw new TypeError('header argument is required')\n  }\n\n  if (!field) {\n    throw new TypeError('field argument is required')\n  }\n\n  // get fields array\n  var fields = !Array.isArray(field)\n    ? parse(String(field))\n    : field\n\n  // assert on invalid field names\n  for (var j = 0; j < fields.length; j++) {\n    if (!FIELD_NAME_REGEXP.test(fields[j])) {\n      throw new TypeError('field argument contains an invalid header name')\n    }\n  }\n\n  // existing, unspecified vary\n  if (header === '*') {\n    return header\n  }\n\n  // enumerate current values\n  var val = header\n  var vals = parse(header.toLowerCase())\n\n  // unspecified vary\n  if (fields.indexOf('*') !== -1 || vals.indexOf('*') !== -1) {\n    return '*'\n  }\n\n  for (var i = 0; i < fields.length; i++) {\n    var fld = fields[i].toLowerCase()\n\n    // append value (case-preserving)\n    if (vals.indexOf(fld) === -1) {\n      vals.push(fld)\n      val = val\n        ? val + ', ' + fields[i]\n        : fields[i]\n    }\n  }\n\n  return val\n}\n\n/**\n * Parse a vary header into an array.\n *\n * @param {String} header\n * @return {Array}\n * @private\n */\n\nfunction parse (header) {\n  var end = 0\n  var list = []\n  var start = 0\n\n  // gather tokens\n  for (var i = 0, len = header.length; i < len; i++) {\n    switch (header.charCodeAt(i)) {\n      case 0x20: /*   */\n        if (start === end) {\n          start = end = i + 1\n        }\n        break\n      case 0x2c: /* , */\n        list.push(header.substring(start, end))\n        start = end = i + 1\n        break\n      default:\n        end = i + 1\n        break\n    }\n  }\n\n  // final token\n  list.push(header.substring(start, end))\n\n  return list\n}\n\n/**\n * Mark that a request is varied on a header field.\n *\n * @param {Object} res\n * @param {String|Array} field\n * @public\n */\n\nfunction vary (res, field) {\n  if (!res || !res.getHeader || !res.setHeader) {\n    // quack quack\n    throw new TypeError('res argument is required')\n  }\n\n  // get existing header\n  var val = res.getHeader('Vary') || ''\n  var header = Array.isArray(val)\n    ? val.join(', ')\n    : String(val)\n\n  // set new header\n  if ((val = append(header, field))) {\n    res.setHeader('Vary', val)\n  }\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","append","header","field","TypeError","fields","Array","isArray","parse","String","j","length","FIELD_NAME_REGEXP","test","val","vals","toLowerCase","indexOf","i","fld","push","end","list","start","len","charCodeAt","substring","vary","res","getHeader","setHeader","join"]
}
