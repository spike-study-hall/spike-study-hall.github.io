{"version":3,"sources":["frp/clojure/core.cljc"],"mappings":"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","names":["var_args","G__59907","frp.clojure.core/reduce","js/Error","f","e","frp.primitives.event.transduce.cljs$core$IFn$_invoke$arity$4","cljs.core.drop.cljs$core$IFn$_invoke$arity$1","p__59912","map__59913","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$2","event-value","start","element","aid.unit/unit","G__59909","G__59910","cats.core/<$>","x","G__59918","G__59919","cats.core/<>","*net-id*-orig-val__59920","frp.primitives.net/*net-id*","*net-id*-temp-val__59921","frp.primitives.event/pure","frp.clojure.core/reduce*","cljs.core.comp.cljs$core$IFn$_invoke$arity$2","cljs.core/second","cljs.core/vector","frp.clojure.core/filter","pred","cljs.core.filter.cljs$core$IFn$_invoke$arity$1","frp.clojure.core/remove","cljs.core/complement","frp.clojure.core/max","cljs.core.partial.cljs$core$IFn$_invoke$arity$3","cljs.core/max","js/Number.NEGATIVE_INFINITY","frp.clojure.core/min","cljs.core/min","frp.primitives.event/positive-infinity","frp.clojure.core/+","cljs.core.partial.cljs$core$IFn$_invoke$arity$2","cljs.core/+","frp.clojure.core/count","frp.primitives.event/transduce","cljs.core.map.cljs$core$IFn$_invoke$arity$1","cljs.core/constantly","frp.clojure.core/drop","n","frp.primitives.event.transduce.cljs$core$IFn$_invoke$arity$3","frp.clojure.core/merge-with","frp.clojure.core.reduce.cljs$core$IFn$_invoke$arity$2","cljs.core/merge-with","frp.clojure.core/group-by","frp.clojure.core.reduce.cljs$core$IFn$_invoke$arity$3","reduction","cljs.core.update.cljs$core$IFn$_invoke$arity$3","com.rpl.specter/setval*","com.rpl.specter/AFTER-ELEM","frp.clojure.core/distinct","cljs.core.distinct.cljs$core$IFn$_invoke$arity$0","G__59929","frp.clojure.core/partition","frp.clojure.core.partition.cljs$core$IFn$_invoke$arity$3","step","G__59955","G__59956","G__59957","aid.core/if-then","cljs.core.comp.cljs$core$IFn$_invoke$arity$3","cljs.core/zero?","aid.core/flip","cljs.core/mod","com.rpl.specter.impl/compiled-setval*","info__41236__auto__","frp.clojure.core/pathcache59947","info59948","com.rpl.specter.impl/magic-precompilation","com.rpl.specter.impl/->VarUse","com.rpl.specter/ALL","precompiled59949","com.rpl.specter.impl/cached-path-info-precompiled","dynamic?__41237__auto__","com.rpl.specter.impl/cached-path-info-dynamic?","G__59952","com.rpl.specter.impl/compiled-transform*","frp.clojure.core/pathcache59943","info59944","precompiled59945","G__59946","cljs.core/remove","cljs.core/<","cljs.core/count","frp.clojure.core/pathcache59935","info59936","precompiled59937","G__59942","cljs.core/inc","G__59930","G__59931","cljs.core/first","cljs.core/=","frp.clojure.core/vector","cljs.core/conj","frp.clojure.core/dedupe","cljs.core.dedupe.cljs$core$IFn$_invoke$arity$0","frp.clojure.core/merge","cljs.core/merge"],"sourcesContent":["(ns frp.clojure.core\n  (:refer-clojure :exclude [+\n                            count\n                            dedupe\n                            distinct\n                            drop\n                            filter\n                            group-by\n                            max\n                            merge\n                            merge-with\n                            min\n                            partition\n                            reduce\n                            remove\n                            vector])\n  (:require [clojure.core :as core]\n            [aid.core :as aid]\n            [aid.unit :as unit]\n            [cats.core :as m]\n            [com.rpl.specter :as s]\n            [frp.primitives.event :as event]\n            [frp.primitives.net :as net]))\n\n(defn reduce\n  ([f e]\n   (->> e\n        (event/transduce (core/drop 0)\n                         (fn [{:keys [event-value start]} element]\n                           {:event-value (if start\n                                           element\n                                           (f event-value element))\n                            :start       false})\n                         {:event-value unit/unit\n                          :start       true})\n        (m/<$> :event-value)))\n  ([f x e]\n   (m/<> (net/with-net e\n                       (event/pure x))\n         (event/transduce (core/drop 0) f x e))))\n\n(def reduce*\n  (comp second\n        core/vector))\n\n(defn filter\n  [pred e]\n  (event/transduce (core/filter pred) reduce* unit/unit e))\n\n(defn remove\n  [pred e]\n  (filter (complement pred) e))\n\n(def max\n  (partial reduce core/max #?(:clj  Double/NEGATIVE_INFINITY\n                              :cljs js/Number.NEGATIVE_INFINITY)))\n\n(def min\n  (partial reduce core/min event/positive-infinity))\n\n(def +\n  (partial reduce core/+))\n\n(def count\n  (partial event/transduce (map (constantly 1)) core/+))\n\n(defn drop\n  [n e]\n  (event/transduce (core/drop n) reduce* e))\n\n(defn merge-with\n  [f e]\n  (reduce (partial core/merge-with f) e))\n\n(defn group-by\n  [f e]\n  (reduce (fn [reduction element]\n            (update reduction\n                    (f element)\n                    (partial s/setval* s/AFTER-ELEM element)))\n          {}\n          e))\n\n(def distinct\n  (partial event/transduce (core/distinct) reduce*))\n\n(defn partition\n  ([n e]\n   (partition n n e))\n  ([n step e]\n   (->> e\n        (reduce (fn [reduction element]\n                  (->> reduction\n                       (aid/if-then (comp zero?\n                                          (partial (aid/flip mod) step)\n                                          :start)\n                                    (partial s/setval*\n                                             [:occs\n                                              s/AFTER-ELEM]\n                                             []))\n                       (s/setval [:occs s/ALL s/AFTER-ELEM] element)\n                       (s/transform :occs\n                                    (partial core/remove (comp (partial < n)\n                                                               core/count)))\n                       (s/transform :start inc)))\n                {:occs  []\n                 :start 0})\n        (m/<$> (comp first\n                     :occs))\n        (filter (comp (partial = n)\n                      core/count)))))\n\n(def vector\n  (partial reduce core/conj []))\n\n(def dedupe\n  (partial event/transduce (core/dedupe) reduce*))\n\n(def merge\n  (partial reduce core/merge))\n"]}