{
"version":3,
"file":"module$node_modules$type_is$index.js",
"lineCount":4,
"mappings":"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",
"sources":["node_modules/type-is/index.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$type_is$index\"] = function(global,require,module,exports) {\n/*!\n * type-is\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar typer = require('media-typer')\nvar mime = require('mime-types')\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = typeofrequest\nmodule.exports.is = typeis\nmodule.exports.hasBody = hasbody\nmodule.exports.normalize = normalize\nmodule.exports.match = mimeMatch\n\n/**\n * Compare a `value` content-type with `types`.\n * Each `type` can be an extension like `html`,\n * a special shortcut like `multipart` or `urlencoded`,\n * or a mime type.\n *\n * If no types match, `false` is returned.\n * Otherwise, the first `type` that matches is returned.\n *\n * @param {String} value\n * @param {Array} types\n * @public\n */\n\nfunction typeis (value, types_) {\n  var i\n  var types = types_\n\n  // remove parameters and normalize\n  var val = tryNormalizeType(value)\n\n  // no type or invalid\n  if (!val) {\n    return false\n  }\n\n  // support flattened arguments\n  if (types && !Array.isArray(types)) {\n    types = new Array(arguments.length - 1)\n    for (i = 0; i < types.length; i++) {\n      types[i] = arguments[i + 1]\n    }\n  }\n\n  // no types, return the content type\n  if (!types || !types.length) {\n    return val\n  }\n\n  var type\n  for (i = 0; i < types.length; i++) {\n    if (mimeMatch(normalize(type = types[i]), val)) {\n      return type[0] === '+' || type.indexOf('*') !== -1\n        ? val\n        : type\n    }\n  }\n\n  // no matches\n  return false\n}\n\n/**\n * Check if a request has a request body.\n * A request with a body __must__ either have `transfer-encoding`\n * or `content-length` headers set.\n * http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3\n *\n * @param {Object} request\n * @return {Boolean}\n * @public\n */\n\nfunction hasbody (req) {\n  return req.headers['transfer-encoding'] !== undefined ||\n    !isNaN(req.headers['content-length'])\n}\n\n/**\n * Check if the incoming request contains the \"Content-Type\"\n * header field, and it contains any of the give mime `type`s.\n * If there is no request body, `null` is returned.\n * If there is no content type, `false` is returned.\n * Otherwise, it returns the first `type` that matches.\n *\n * Examples:\n *\n *     // With Content-Type: text/html; charset=utf-8\n *     this.is('html'); // => 'html'\n *     this.is('text/html'); // => 'text/html'\n *     this.is('text/*', 'application/json'); // => 'text/html'\n *\n *     // When Content-Type is application/json\n *     this.is('json', 'urlencoded'); // => 'json'\n *     this.is('application/json'); // => 'application/json'\n *     this.is('html', 'application/*'); // => 'application/json'\n *\n *     this.is('html'); // => false\n *\n * @param {String|Array} types...\n * @return {String|false|null}\n * @public\n */\n\nfunction typeofrequest (req, types_) {\n  var types = types_\n\n  // no body\n  if (!hasbody(req)) {\n    return null\n  }\n\n  // support flattened arguments\n  if (arguments.length > 2) {\n    types = new Array(arguments.length - 1)\n    for (var i = 0; i < types.length; i++) {\n      types[i] = arguments[i + 1]\n    }\n  }\n\n  // request content type\n  var value = req.headers['content-type']\n\n  return typeis(value, types)\n}\n\n/**\n * Normalize a mime type.\n * If it's a shorthand, expand it to a valid mime type.\n *\n * In general, you probably want:\n *\n *   var type = is(req, ['urlencoded', 'json', 'multipart']);\n *\n * Then use the appropriate body parsers.\n * These three are the most common request body types\n * and are thus ensured to work.\n *\n * @param {String} type\n * @private\n */\n\nfunction normalize (type) {\n  if (typeof type !== 'string') {\n    // invalid type\n    return false\n  }\n\n  switch (type) {\n    case 'urlencoded':\n      return 'application/x-www-form-urlencoded'\n    case 'multipart':\n      return 'multipart/*'\n  }\n\n  if (type[0] === '+') {\n    // \"+json\" -> \"*/*+json\" expando\n    return '*/*' + type\n  }\n\n  return type.indexOf('/') === -1\n    ? mime.lookup(type)\n    : type\n}\n\n/**\n * Check if `expected` mime type\n * matches `actual` mime type with\n * wildcard and +suffix support.\n *\n * @param {String} expected\n * @param {String} actual\n * @return {Boolean}\n * @private\n */\n\nfunction mimeMatch (expected, actual) {\n  // invalid type\n  if (expected === false) {\n    return false\n  }\n\n  // split types\n  var actualParts = actual.split('/')\n  var expectedParts = expected.split('/')\n\n  // invalid format\n  if (actualParts.length !== 2 || expectedParts.length !== 2) {\n    return false\n  }\n\n  // validate type\n  if (expectedParts[0] !== '*' && expectedParts[0] !== actualParts[0]) {\n    return false\n  }\n\n  // validate suffix wildcard\n  if (expectedParts[1].substr(0, 2) === '*+') {\n    return expectedParts[1].length <= actualParts[1].length + 1 &&\n      expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length)\n  }\n\n  // validate subtype\n  if (expectedParts[1] !== '*' && expectedParts[1] !== actualParts[1]) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * Normalize a type and remove parameters.\n *\n * @param {string} value\n * @return {string}\n * @private\n */\n\nfunction normalizeType (value) {\n  // parse the type\n  var type = typer.parse(value)\n\n  // remove the parameters\n  type.parameters = undefined\n\n  // reformat it\n  return typer.format(type)\n}\n\n/**\n * Try to normalize a type and remove parameters.\n *\n * @param {string} value\n * @return {string}\n * @private\n */\n\nfunction tryNormalizeType (value) {\n  if (!value) {\n    return null\n  }\n\n  try {\n    return normalizeType(value)\n  } catch (err) {\n    return null\n  }\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","typeis","value","types_","types","type","typer","parse","parameters","undefined","format","err","val","Array","isArray","arguments","length","i","mimeMatch","normalize","indexOf","hasbody","req","headers","isNaN","mime","lookup","expected","actual","actualParts","split","expectedParts","substr","typeofrequest","is","hasBody","match"]
}
