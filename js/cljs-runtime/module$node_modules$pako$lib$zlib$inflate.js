shadow$provide.module$node_modules$pako$lib$zlib$inflate=function(global,require,module,exports){function zswap32(q){return(q>>>24&255)+(q>>>8&65280)+((q&65280)<<8)+((q&255)<<24)}function InflateState(){this.mode=0;this.last=!1;this.wrap=0;this.havedict=!1;this.total=this.check=this.dmax=this.flags=0;this.head=null;this.wnext=this.whave=this.wsize=this.wbits=0;this.window=null;this.extra=this.offset=this.length=this.bits=this.hold=0;this.distcode=this.lencode=null;this.have=this.ndist=this.nlen=this.ncode=
this.distbits=this.lenbits=0;this.next=null;this.lens=new utils.Buf16(320);this.work=new utils.Buf16(288);this.distdyn=this.lendyn=null;this.was=this.back=this.sane=0}function inflateResetKeep(strm){if(!strm||!strm.state)return-2;var state=strm.state;strm.total_in=strm.total_out=state.total=0;strm.msg="";state.wrap&&(strm.adler=state.wrap&1);state.mode=1;state.last=0;state.havedict=0;state.dmax=32768;state.head=null;state.hold=0;state.bits=0;state.lencode=state.lendyn=new utils.Buf32(852);state.distcode=
state.distdyn=new utils.Buf32(592);state.sane=1;state.back=-1;return 0}function inflateReset(strm){if(!strm||!strm.state)return-2;var state=strm.state;state.wsize=0;state.whave=0;state.wnext=0;return inflateResetKeep(strm)}function inflateReset2(strm,windowBits){if(!strm||!strm.state)return-2;var state=strm.state;if(0>windowBits){var wrap=0;windowBits=-windowBits}else wrap=(windowBits>>4)+1,48>windowBits&&(windowBits&=15);if(windowBits&&(8>windowBits||15<windowBits))return-2;null!==state.window&&
state.wbits!==windowBits&&(state.window=null);state.wrap=wrap;state.wbits=windowBits;return inflateReset(strm)}function inflateInit2(strm,windowBits){if(!strm)return-2;var state=new InflateState;strm.state=state;state.window=null;windowBits=inflateReset2(strm,windowBits);0!==windowBits&&(strm.state=null);return windowBits}function updatewindow(strm,src,end,copy){var state=strm.state;null===state.window&&(state.wsize=1<<state.wbits,state.wnext=0,state.whave=0,state.window=new utils.Buf8(state.wsize));
copy>=state.wsize?(utils.arraySet(state.window,src,end-state.wsize,state.wsize,0),state.wnext=0,state.whave=state.wsize):(strm=state.wsize-state.wnext,strm>copy&&(strm=copy),utils.arraySet(state.window,src,end-copy,strm,state.wnext),(copy-=strm)?(utils.arraySet(state.window,src,end-copy,copy,0),state.wnext=copy,state.whave=state.wsize):(state.wnext+=strm,state.wnext===state.wsize&&(state.wnext=0),state.whave<state.wsize&&(state.whave+=strm)));return 0}var utils=require("module$node_modules$pako$lib$utils$common"),
adler32=require("module$node_modules$pako$lib$zlib$adler32"),crc32=require("module$node_modules$pako$lib$zlib$crc32"),inflate_fast=require("module$node_modules$pako$lib$zlib$inffast"),inflate_table=require("module$node_modules$pako$lib$zlib$inftrees"),virgin=!0,lenfix,distfix;exports.inflateReset=inflateReset;exports.inflateReset2=inflateReset2;exports.inflateResetKeep=inflateResetKeep;exports.inflateInit=function(strm){return inflateInit2(strm,15)};exports.inflateInit2=inflateInit2;exports.inflate=
function(strm,flush){var last_val,hbuf=new utils.Buf8(4),order=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!strm||!strm.state||!strm.output||!strm.input&&0!==strm.avail_in)return-2;var state=strm.state;12===state.mode&&(state.mode=13);var put=strm.next_out;var output=strm.output;var left=strm.avail_out;var next=strm.next_in;var input=strm.input;var have=strm.avail_in;var hold=state.hold;var bits=state.bits;var _in=have;var _out=left;var ret=0;a:for(;;)switch(state.mode){case 1:if(0===state.wrap){state.mode=
13;break}for(;16>bits;){if(0===have)break a;have--;hold+=input[next++]<<bits;bits+=8}if(state.wrap&2&&35615===hold){state.check=0;hbuf[0]=hold&255;hbuf[1]=hold>>>8&255;state.check=crc32(state.check,hbuf,2,0);bits=hold=0;state.mode=2;break}state.flags=0;state.head&&(state.head.done=!1);if(!(state.wrap&1)||(((hold&255)<<8)+(hold>>8))%31){strm.msg="incorrect header check";state.mode=30;break}if(8!==(hold&15)){strm.msg="unknown compression method";state.mode=30;break}hold>>>=4;bits-=4;var from=(hold&
15)+8;if(0===state.wbits)state.wbits=from;else if(from>state.wbits){strm.msg="invalid window size";state.mode=30;break}state.dmax=1<<from;strm.adler=state.check=1;state.mode=hold&512?10:12;bits=hold=0;break;case 2:for(;16>bits;){if(0===have)break a;have--;hold+=input[next++]<<bits;bits+=8}state.flags=hold;if(8!==(state.flags&255)){strm.msg="unknown compression method";state.mode=30;break}if(state.flags&57344){strm.msg="unknown header flags set";state.mode=30;break}state.head&&(state.head.text=hold>>
8&1);state.flags&512&&(hbuf[0]=hold&255,hbuf[1]=hold>>>8&255,state.check=crc32(state.check,hbuf,2,0));bits=hold=0;state.mode=3;case 3:for(;32>bits;){if(0===have)break a;have--;hold+=input[next++]<<bits;bits+=8}state.head&&(state.head.time=hold);state.flags&512&&(hbuf[0]=hold&255,hbuf[1]=hold>>>8&255,hbuf[2]=hold>>>16&255,hbuf[3]=hold>>>24&255,state.check=crc32(state.check,hbuf,4,0));bits=hold=0;state.mode=4;case 4:for(;16>bits;){if(0===have)break a;have--;hold+=input[next++]<<bits;bits+=8}state.head&&
(state.head.xflags=hold&255,state.head.os=hold>>8);state.flags&512&&(hbuf[0]=hold&255,hbuf[1]=hold>>>8&255,state.check=crc32(state.check,hbuf,2,0));bits=hold=0;state.mode=5;case 5:if(state.flags&1024){for(;16>bits;){if(0===have)break a;have--;hold+=input[next++]<<bits;bits+=8}state.length=hold;state.head&&(state.head.extra_len=hold);state.flags&512&&(hbuf[0]=hold&255,hbuf[1]=hold>>>8&255,state.check=crc32(state.check,hbuf,2,0));bits=hold=0}else state.head&&(state.head.extra=null);state.mode=6;case 6:if(state.flags&
1024){var copy=state.length;copy>have&&(copy=have);copy&&(state.head&&(from=state.head.extra_len-state.length,state.head.extra||(state.head.extra=Array(state.head.extra_len)),utils.arraySet(state.head.extra,input,next,copy,from)),state.flags&512&&(state.check=crc32(state.check,input,copy,next)),have-=copy,next+=copy,state.length-=copy);if(state.length)break a}state.length=0;state.mode=7;case 7:if(state.flags&2048){if(0===have)break a;copy=0;do from=input[next+copy++],state.head&&from&&65536>state.length&&
(state.head.name+=String.fromCharCode(from));while(from&&copy<have);state.flags&512&&(state.check=crc32(state.check,input,copy,next));have-=copy;next+=copy;if(from)break a}else state.head&&(state.head.name=null);state.length=0;state.mode=8;case 8:if(state.flags&4096){if(0===have)break a;copy=0;do from=input[next+copy++],state.head&&from&&65536>state.length&&(state.head.comment+=String.fromCharCode(from));while(from&&copy<have);state.flags&512&&(state.check=crc32(state.check,input,copy,next));have-=
copy;next+=copy;if(from)break a}else state.head&&(state.head.comment=null);state.mode=9;case 9:if(state.flags&512){for(;16>bits;){if(0===have)break a;have--;hold+=input[next++]<<bits;bits+=8}if(hold!==(state.check&65535)){strm.msg="header crc mismatch";state.mode=30;break}bits=hold=0}state.head&&(state.head.hcrc=state.flags>>9&1,state.head.done=!0);strm.adler=state.check=0;state.mode=12;break;case 10:for(;32>bits;){if(0===have)break a;have--;hold+=input[next++]<<bits;bits+=8}strm.adler=state.check=
zswap32(hold);bits=hold=0;state.mode=11;case 11:if(0===state.havedict)return strm.next_out=put,strm.avail_out=left,strm.next_in=next,strm.avail_in=have,state.hold=hold,state.bits=bits,2;strm.adler=state.check=1;state.mode=12;case 12:if(5===flush||6===flush)break a;case 13:if(state.last){hold>>>=bits&7;bits-=bits&7;state.mode=27;break}for(;3>bits;){if(0===have)break a;have--;hold+=input[next++]<<bits;bits+=8}state.last=hold&1;hold>>>=1;--bits;switch(hold&3){case 0:state.mode=14;break;case 1:from=state;
if(virgin){lenfix=new utils.Buf32(512);distfix=new utils.Buf32(32);for(copy=0;144>copy;)from.lens[copy++]=8;for(;256>copy;)from.lens[copy++]=9;for(;280>copy;)from.lens[copy++]=7;for(;288>copy;)from.lens[copy++]=8;inflate_table(1,from.lens,0,288,lenfix,0,from.work,{bits:9});for(copy=0;32>copy;)from.lens[copy++]=5;inflate_table(2,from.lens,0,32,distfix,0,from.work,{bits:5});virgin=!1}from.lencode=lenfix;from.lenbits=9;from.distcode=distfix;from.distbits=5;state.mode=20;if(6===flush){hold>>>=2;bits-=
2;break a}break;case 2:state.mode=17;break;case 3:strm.msg="invalid block type",state.mode=30}hold>>>=2;bits-=2;break;case 14:hold>>>=bits&7;for(bits-=bits&7;32>bits;){if(0===have)break a;have--;hold+=input[next++]<<bits;bits+=8}if((hold&65535)!==(hold>>>16^65535)){strm.msg="invalid stored block lengths";state.mode=30;break}state.length=hold&65535;bits=hold=0;state.mode=15;if(6===flush)break a;case 15:state.mode=16;case 16:if(copy=state.length){copy>have&&(copy=have);copy>left&&(copy=left);if(0===
copy)break a;utils.arraySet(output,input,next,copy,put);have-=copy;next+=copy;left-=copy;put+=copy;state.length-=copy;break}state.mode=12;break;case 17:for(;14>bits;){if(0===have)break a;have--;hold+=input[next++]<<bits;bits+=8}state.nlen=(hold&31)+257;hold>>>=5;bits-=5;state.ndist=(hold&31)+1;hold>>>=5;bits-=5;state.ncode=(hold&15)+4;hold>>>=4;bits-=4;if(286<state.nlen||30<state.ndist){strm.msg="too many length or distance symbols";state.mode=30;break}state.have=0;state.mode=18;case 18:for(;state.have<
state.ncode;){for(;3>bits;){if(0===have)break a;have--;hold+=input[next++]<<bits;bits+=8}state.lens[order[state.have++]]=hold&7;hold>>>=3;bits-=3}for(;19>state.have;)state.lens[order[state.have++]]=0;state.lencode=state.lendyn;state.lenbits=7;copy={bits:state.lenbits};ret=inflate_table(0,state.lens,0,19,state.lencode,0,state.work,copy);state.lenbits=copy.bits;if(ret){strm.msg="invalid code lengths set";state.mode=30;break}state.have=0;state.mode=19;case 19:for(;state.have<state.nlen+state.ndist;){for(;;){var here=
state.lencode[hold&(1<<state.lenbits)-1];copy=here>>>24;here&=65535;if(copy<=bits)break;if(0===have)break a;have--;hold+=input[next++]<<bits;bits+=8}if(16>here)hold>>>=copy,bits-=copy,state.lens[state.have++]=here;else{if(16===here){for(from=copy+2;bits<from;){if(0===have)break a;have--;hold+=input[next++]<<bits;bits+=8}hold>>>=copy;bits-=copy;if(0===state.have){strm.msg="invalid bit length repeat";state.mode=30;break}from=state.lens[state.have-1];copy=3+(hold&3);hold>>>=2;bits-=2}else if(17===here){for(from=
copy+3;bits<from;){if(0===have)break a;have--;hold+=input[next++]<<bits;bits+=8}hold>>>=copy;bits-=copy;from=0;copy=3+(hold&7);hold>>>=3;bits-=3}else{for(from=copy+7;bits<from;){if(0===have)break a;have--;hold+=input[next++]<<bits;bits+=8}hold>>>=copy;bits-=copy;from=0;copy=11+(hold&127);hold>>>=7;bits-=7}if(state.have+copy>state.nlen+state.ndist){strm.msg="invalid bit length repeat";state.mode=30;break}for(;copy--;)state.lens[state.have++]=from}}if(30===state.mode)break;if(0===state.lens[256]){strm.msg=
"invalid code -- missing end-of-block";state.mode=30;break}state.lenbits=9;copy={bits:state.lenbits};ret=inflate_table(1,state.lens,0,state.nlen,state.lencode,0,state.work,copy);state.lenbits=copy.bits;if(ret){strm.msg="invalid literal/lengths set";state.mode=30;break}state.distbits=6;state.distcode=state.distdyn;copy={bits:state.distbits};ret=inflate_table(2,state.lens,state.nlen,state.ndist,state.distcode,0,state.work,copy);state.distbits=copy.bits;if(ret){strm.msg="invalid distances set";state.mode=
30;break}state.mode=20;if(6===flush)break a;case 20:state.mode=21;case 21:if(6<=have&&258<=left){strm.next_out=put;strm.avail_out=left;strm.next_in=next;strm.avail_in=have;state.hold=hold;state.bits=bits;inflate_fast(strm,_out);put=strm.next_out;output=strm.output;left=strm.avail_out;next=strm.next_in;input=strm.input;have=strm.avail_in;hold=state.hold;bits=state.bits;12===state.mode&&(state.back=-1);break}for(state.back=0;;){here=state.lencode[hold&(1<<state.lenbits)-1];copy=here>>>24;from=here>>>
16&255;here&=65535;if(copy<=bits)break;if(0===have)break a;have--;hold+=input[next++]<<bits;bits+=8}if(from&&0===(from&240)){var from_source=copy;var last_op=from;for(last_val=here;;){here=state.lencode[last_val+((hold&(1<<from_source+last_op)-1)>>from_source)];copy=here>>>24;from=here>>>16&255;here&=65535;if(from_source+copy<=bits)break;if(0===have)break a;have--;hold+=input[next++]<<bits;bits+=8}hold>>>=from_source;bits-=from_source;state.back+=from_source}hold>>>=copy;bits-=copy;state.back+=copy;
state.length=here;if(0===from){state.mode=26;break}if(from&32){state.back=-1;state.mode=12;break}if(from&64){strm.msg="invalid literal/length code";state.mode=30;break}state.extra=from&15;state.mode=22;case 22:if(state.extra){for(from=state.extra;bits<from;){if(0===have)break a;have--;hold+=input[next++]<<bits;bits+=8}state.length+=hold&(1<<state.extra)-1;hold>>>=state.extra;bits-=state.extra;state.back+=state.extra}state.was=state.length;state.mode=23;case 23:for(;;){here=state.distcode[hold&(1<<
state.distbits)-1];copy=here>>>24;from=here>>>16&255;here&=65535;if(copy<=bits)break;if(0===have)break a;have--;hold+=input[next++]<<bits;bits+=8}if(0===(from&240)){from_source=copy;last_op=from;for(last_val=here;;){here=state.distcode[last_val+((hold&(1<<from_source+last_op)-1)>>from_source)];copy=here>>>24;from=here>>>16&255;here&=65535;if(from_source+copy<=bits)break;if(0===have)break a;have--;hold+=input[next++]<<bits;bits+=8}hold>>>=from_source;bits-=from_source;state.back+=from_source}hold>>>=
copy;bits-=copy;state.back+=copy;if(from&64){strm.msg="invalid distance code";state.mode=30;break}state.offset=here;state.extra=from&15;state.mode=24;case 24:if(state.extra){for(from=state.extra;bits<from;){if(0===have)break a;have--;hold+=input[next++]<<bits;bits+=8}state.offset+=hold&(1<<state.extra)-1;hold>>>=state.extra;bits-=state.extra;state.back+=state.extra}if(state.offset>state.dmax){strm.msg="invalid distance too far back";state.mode=30;break}state.mode=25;case 25:if(0===left)break a;copy=
_out-left;if(state.offset>copy){copy=state.offset-copy;if(copy>state.whave&&state.sane){strm.msg="invalid distance too far back";state.mode=30;break}copy>state.wnext?(copy-=state.wnext,from=state.wsize-copy):from=state.wnext-copy;copy>state.length&&(copy=state.length);from_source=state.window}else from_source=output,from=put-state.offset,copy=state.length;copy>left&&(copy=left);left-=copy;state.length-=copy;do output[put++]=from_source[from++];while(--copy);0===state.length&&(state.mode=21);break;
case 26:if(0===left)break a;output[put++]=state.length;left--;state.mode=21;break;case 27:if(state.wrap){for(;32>bits;){if(0===have)break a;have--;hold|=input[next++]<<bits;bits+=8}_out-=left;strm.total_out+=_out;state.total+=_out;_out&&(strm.adler=state.check=state.flags?crc32(state.check,output,_out,put-_out):adler32(state.check,output,_out,put-_out));_out=left;if((state.flags?hold:zswap32(hold))!==state.check){strm.msg="incorrect data check";state.mode=30;break}bits=hold=0}state.mode=28;case 28:if(state.wrap&&
state.flags){for(;32>bits;){if(0===have)break a;have--;hold+=input[next++]<<bits;bits+=8}if(hold!==(state.total&4294967295)){strm.msg="incorrect length check";state.mode=30;break}bits=hold=0}state.mode=29;case 29:ret=1;break a;case 30:ret=-3;break a;case 31:return-4;default:return-2}strm.next_out=put;strm.avail_out=left;strm.next_in=next;strm.avail_in=have;state.hold=hold;state.bits=bits;if((state.wsize||_out!==strm.avail_out&&30>state.mode&&(27>state.mode||4!==flush))&&updatewindow(strm,strm.output,
strm.next_out,_out-strm.avail_out))return state.mode=31,-4;_in-=strm.avail_in;_out-=strm.avail_out;strm.total_in+=_in;strm.total_out+=_out;state.total+=_out;state.wrap&&_out&&(strm.adler=state.check=state.flags?crc32(state.check,output,_out,strm.next_out-_out):adler32(state.check,output,_out,strm.next_out-_out));strm.data_type=state.bits+(state.last?64:0)+(12===state.mode?128:0)+(20===state.mode||15===state.mode?256:0);(0===_in&&0===_out||4===flush)&&0===ret&&(ret=-5);return ret};exports.inflateEnd=
function(strm){if(!strm||!strm.state)return-2;var state=strm.state;state.window&&(state.window=null);strm.state=null;return 0};exports.inflateGetHeader=function(strm,head){if(!strm||!strm.state)return-2;strm=strm.state;if(0===(strm.wrap&2))return-2;strm.head=head;head.done=!1;return 0};exports.inflateSetDictionary=function(strm,dictionary){var dictLength=dictionary.length;if(!strm||!strm.state)return-2;var state=strm.state;if(0!==state.wrap&&11!==state.mode)return-2;if(11===state.mode){var dictid=
adler32(1,dictionary,dictLength,0);if(dictid!==state.check)return-3}if(updatewindow(strm,dictionary,dictLength,dictLength))return state.mode=31,-4;state.havedict=1;return 0};exports.inflateInfo="pako inflate (from Nodeca project)"}
//# sourceMappingURL=module$node_modules$pako$lib$zlib$inflate.js.map
