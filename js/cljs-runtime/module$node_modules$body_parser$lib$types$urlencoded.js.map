{
"version":3,
"file":"module$node_modules$body_parser$lib$types$urlencoded.js",
"lineCount":8,
"mappings":"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",
"sources":["node_modules/body-parser/lib/types/urlencoded.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$body_parser$lib$types$urlencoded\"] = function(global,require,module,exports) {\n/*!\n * body-parser\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar bytes = require('bytes')\nvar contentType = require('content-type')\nvar createError = require('http-errors')\nvar debug = require('debug')('body-parser:urlencoded')\nvar deprecate = require('depd')('body-parser')\nvar read = require('../read')\nvar typeis = require('type-is')\n\n/**\n * Module exports.\n */\n\nmodule.exports = urlencoded\n\n/**\n * Cache of parser modules.\n */\n\nvar parsers = Object.create(null)\n\n/**\n * Create a middleware to parse urlencoded bodies.\n *\n * @param {object} [options]\n * @return {function}\n * @public\n */\n\nfunction urlencoded (options) {\n  var opts = options || {}\n\n  // notice because option default will flip in next major\n  if (opts.extended === undefined) {\n    deprecate('undefined extended: provide extended option')\n  }\n\n  var extended = opts.extended !== false\n  var inflate = opts.inflate !== false\n  var limit = typeof opts.limit !== 'number'\n    ? bytes.parse(opts.limit || '100kb')\n    : opts.limit\n  var type = opts.type || 'application/x-www-form-urlencoded'\n  var verify = opts.verify || false\n\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function')\n  }\n\n  // create the appropriate query parser\n  var queryparse = extended\n    ? extendedparser(opts)\n    : simpleparser(opts)\n\n  // create the appropriate type checking function\n  var shouldParse = typeof type !== 'function'\n    ? typeChecker(type)\n    : type\n\n  function parse (body) {\n    return body.length\n      ? queryparse(body)\n      : {}\n  }\n\n  return function urlencodedParser (req, res, next) {\n    if (req._body) {\n      debug('body already parsed')\n      next()\n      return\n    }\n\n    req.body = req.body || {}\n\n    // skip requests without bodies\n    if (!typeis.hasBody(req)) {\n      debug('skip empty body')\n      next()\n      return\n    }\n\n    debug('content-type %j', req.headers['content-type'])\n\n    // determine if request should be parsed\n    if (!shouldParse(req)) {\n      debug('skip parsing')\n      next()\n      return\n    }\n\n    // assert charset\n    var charset = getCharset(req) || 'utf-8'\n    if (charset !== 'utf-8') {\n      debug('invalid charset')\n      next(createError(415, 'unsupported charset \"' + charset.toUpperCase() + '\"', {\n        charset: charset,\n        type: 'charset.unsupported'\n      }))\n      return\n    }\n\n    // read\n    read(req, res, next, parse, debug, {\n      debug: debug,\n      encoding: charset,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    })\n  }\n}\n\n/**\n * Get the extended query parser.\n *\n * @param {object} options\n */\n\nfunction extendedparser (options) {\n  var parameterLimit = options.parameterLimit !== undefined\n    ? options.parameterLimit\n    : 1000\n  var parse = parser('qs')\n\n  if (isNaN(parameterLimit) || parameterLimit < 1) {\n    throw new TypeError('option parameterLimit must be a positive number')\n  }\n\n  if (isFinite(parameterLimit)) {\n    parameterLimit = parameterLimit | 0\n  }\n\n  return function queryparse (body) {\n    var paramCount = parameterCount(body, parameterLimit)\n\n    if (paramCount === undefined) {\n      debug('too many parameters')\n      throw createError(413, 'too many parameters', {\n        type: 'parameters.too.many'\n      })\n    }\n\n    var arrayLimit = Math.max(100, paramCount)\n\n    debug('parse extended urlencoding')\n    return parse(body, {\n      allowPrototypes: true,\n      arrayLimit: arrayLimit,\n      depth: Infinity,\n      parameterLimit: parameterLimit\n    })\n  }\n}\n\n/**\n * Get the charset of a request.\n *\n * @param {object} req\n * @api private\n */\n\nfunction getCharset (req) {\n  try {\n    return (contentType.parse(req).parameters.charset || '').toLowerCase()\n  } catch (e) {\n    return undefined\n  }\n}\n\n/**\n * Count the number of parameters, stopping once limit reached\n *\n * @param {string} body\n * @param {number} limit\n * @api private\n */\n\nfunction parameterCount (body, limit) {\n  var count = 0\n  var index = 0\n\n  while ((index = body.indexOf('&', index)) !== -1) {\n    count++\n    index++\n\n    if (count === limit) {\n      return undefined\n    }\n  }\n\n  return count\n}\n\n/**\n * Get parser for module name dynamically.\n *\n * @param {string} name\n * @return {function}\n * @api private\n */\n\nfunction parser (name) {\n  var mod = parsers[name]\n\n  if (mod !== undefined) {\n    return mod.parse\n  }\n\n  // this uses a switch for static require analysis\n  switch (name) {\n    case 'qs':\n      mod = require('qs')\n      break\n    case 'querystring':\n      mod = require('querystring')\n      break\n  }\n\n  // store to prevent invoking require()\n  parsers[name] = mod\n\n  return mod.parse\n}\n\n/**\n * Get the simple query parser.\n *\n * @param {object} options\n */\n\nfunction simpleparser (options) {\n  var parameterLimit = options.parameterLimit !== undefined\n    ? options.parameterLimit\n    : 1000\n  var parse = parser('querystring')\n\n  if (isNaN(parameterLimit) || parameterLimit < 1) {\n    throw new TypeError('option parameterLimit must be a positive number')\n  }\n\n  if (isFinite(parameterLimit)) {\n    parameterLimit = parameterLimit | 0\n  }\n\n  return function queryparse (body) {\n    var paramCount = parameterCount(body, parameterLimit)\n\n    if (paramCount === undefined) {\n      debug('too many parameters')\n      throw createError(413, 'too many parameters', {\n        type: 'parameters.too.many'\n      })\n    }\n\n    debug('parse urlencoding')\n    return parse(body, undefined, undefined, { maxKeys: parameterLimit })\n  }\n}\n\n/**\n * Get the simple type checker.\n *\n * @param {string} type\n * @return {function}\n */\n\nfunction typeChecker (type) {\n  return function checkType (req) {\n    return Boolean(typeis(req, type))\n  }\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","extendedparser","options","parameterLimit","undefined","parse","parser","isNaN","TypeError","isFinite","queryparse","body","paramCount","parameterCount","debug","createError","type","arrayLimit","Math","max","allowPrototypes","depth","Infinity","limit","count","index","indexOf","name","mod","parsers","simpleparser","maxKeys","typeChecker","checkType","req","typeis","bytes","contentType","deprecate","read","urlencoded","length","opts","extended","inflate","verify","shouldParse","urlencodedParser","res","next","_body","hasBody","headers","toLowerCase","parameters","charset","e","toUpperCase","encoding","Object","create"]
}
