{
"version":3,
"file":"module$node_modules$body_parser$lib$types$json.js",
"lineCount":6,
"mappings":"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",
"sources":["node_modules/body-parser/lib/types/json.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$body_parser$lib$types$json\"] = function(global,require,module,exports) {\n/*!\n * body-parser\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar bytes = require('bytes')\nvar contentType = require('content-type')\nvar createError = require('http-errors')\nvar debug = require('debug')('body-parser:json')\nvar read = require('../read')\nvar typeis = require('type-is')\n\n/**\n * Module exports.\n */\n\nmodule.exports = json\n\n/**\n * RegExp to match the first non-space in a string.\n *\n * Allowed whitespace is defined in RFC 7159:\n *\n *    ws = *(\n *            %x20 /              ; Space\n *            %x09 /              ; Horizontal tab\n *            %x0A /              ; Line feed or New line\n *            %x0D )              ; Carriage return\n */\n\nvar FIRST_CHAR_REGEXP = /^[\\x20\\x09\\x0a\\x0d]*(.)/ // eslint-disable-line no-control-regex\n\n/**\n * Create a middleware to parse JSON bodies.\n *\n * @param {object} [options]\n * @return {function}\n * @public\n */\n\nfunction json (options) {\n  var opts = options || {}\n\n  var limit = typeof opts.limit !== 'number'\n    ? bytes.parse(opts.limit || '100kb')\n    : opts.limit\n  var inflate = opts.inflate !== false\n  var reviver = opts.reviver\n  var strict = opts.strict !== false\n  var type = opts.type || 'application/json'\n  var verify = opts.verify || false\n\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function')\n  }\n\n  // create the appropriate type checking function\n  var shouldParse = typeof type !== 'function'\n    ? typeChecker(type)\n    : type\n\n  function parse (body) {\n    if (body.length === 0) {\n      // special-case empty json body, as it's a common client-side mistake\n      // TODO: maybe make this configurable or part of \"strict\" option\n      return {}\n    }\n\n    if (strict) {\n      var first = firstchar(body)\n\n      if (first !== '{' && first !== '[') {\n        debug('strict violation')\n        throw createStrictSyntaxError(body, first)\n      }\n    }\n\n    try {\n      debug('parse json')\n      return JSON.parse(body, reviver)\n    } catch (e) {\n      throw normalizeJsonSyntaxError(e, {\n        message: e.message,\n        stack: e.stack\n      })\n    }\n  }\n\n  return function jsonParser (req, res, next) {\n    if (req._body) {\n      debug('body already parsed')\n      next()\n      return\n    }\n\n    req.body = req.body || {}\n\n    // skip requests without bodies\n    if (!typeis.hasBody(req)) {\n      debug('skip empty body')\n      next()\n      return\n    }\n\n    debug('content-type %j', req.headers['content-type'])\n\n    // determine if request should be parsed\n    if (!shouldParse(req)) {\n      debug('skip parsing')\n      next()\n      return\n    }\n\n    // assert charset per RFC 7159 sec 8.1\n    var charset = getCharset(req) || 'utf-8'\n    if (charset.substr(0, 4) !== 'utf-') {\n      debug('invalid charset')\n      next(createError(415, 'unsupported charset \"' + charset.toUpperCase() + '\"', {\n        charset: charset,\n        type: 'charset.unsupported'\n      }))\n      return\n    }\n\n    // read\n    read(req, res, next, parse, debug, {\n      encoding: charset,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    })\n  }\n}\n\n/**\n * Create strict violation syntax error matching native error.\n *\n * @param {string} str\n * @param {string} char\n * @return {Error}\n * @private\n */\n\nfunction createStrictSyntaxError (str, char) {\n  var index = str.indexOf(char)\n  var partial = str.substring(0, index) + '#'\n\n  try {\n    JSON.parse(partial); /* istanbul ignore next */ throw new SyntaxError('strict violation')\n  } catch (e) {\n    return normalizeJsonSyntaxError(e, {\n      message: e.message.replace('#', char),\n      stack: e.stack\n    })\n  }\n}\n\n/**\n * Get the first non-whitespace character in a string.\n *\n * @param {string} str\n * @return {function}\n * @private\n */\n\nfunction firstchar (str) {\n  return FIRST_CHAR_REGEXP.exec(str)[1]\n}\n\n/**\n * Get the charset of a request.\n *\n * @param {object} req\n * @api private\n */\n\nfunction getCharset (req) {\n  try {\n    return (contentType.parse(req).parameters.charset || '').toLowerCase()\n  } catch (e) {\n    return undefined\n  }\n}\n\n/**\n * Normalize a SyntaxError for JSON.parse.\n *\n * @param {SyntaxError} error\n * @param {object} obj\n * @return {SyntaxError}\n */\n\nfunction normalizeJsonSyntaxError (error, obj) {\n  var keys = Object.getOwnPropertyNames(error)\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i]\n    if (key !== 'stack' && key !== 'message') {\n      delete error[key]\n    }\n  }\n\n  // replace stack before message for Node.js 0.10 and below\n  error.stack = obj.stack.replace(error.message, obj.message)\n  error.message = obj.message\n\n  return error\n}\n\n/**\n * Get the simple type checker.\n *\n * @param {string} type\n * @return {function}\n */\n\nfunction typeChecker (type) {\n  return function checkType (req) {\n    return Boolean(typeis(req, type))\n  }\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","normalizeJsonSyntaxError","error","obj","keys","Object","getOwnPropertyNames","i","length","key","stack","replace","message","typeChecker","type","checkType","req","typeis","bytes","contentType","createError","debug","read","json","options","parse","body","strict","first","FIRST_CHAR_REGEXP","exec","index","indexOf","partial","substring","JSON","SyntaxError","e","reviver","opts","limit","inflate","verify","TypeError","shouldParse","jsonParser","res","next","_body","hasBody","headers","toLowerCase","parameters","charset","undefined","substr","toUpperCase","encoding"]
}
