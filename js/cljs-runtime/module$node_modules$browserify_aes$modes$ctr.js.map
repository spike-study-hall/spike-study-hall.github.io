{
"version":3,
"file":"module$node_modules$browserify_aes$modes$ctr.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,6CAAA,CAAiE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CACzG,IAAIC,IAAMH,OAAA,CAAQ,sCAAR,CAAV,CACII,OAASJ,OAAA,CAAQ,uCAAR,CAAAI,OADb,CAEIC,OAASL,OAAA,CAAQ,2CAAR,CASbE,QAAAI,QAAA,CAAkBC,QAAS,CAACC,IAAD,CAAOC,KAAP,CAAc,CACvC,IAAIC,SAAWC,IAAAC,KAAA,CAAUH,KAAAI,OAAV,CAFDC,EAEC,CAAf,CACIC,MAAQP,IAAAQ,OAAAH,OACZL,KAAAQ,OAAA,CAAcZ,MAAAa,OAAA,CAAc,CAC1BT,IAAAQ,OAD0B,CAE1BZ,MAAAc,YAAA,CANYJ,EAMZ,CAAmBJ,QAAnB,CAF0B,CAAd,CAId,KAAK,IAAIS,EAAI,CAAb,CAAgBA,CAAhB,CAAoBT,QAApB,CAA8BS,CAAA,EAA9B,CAAmC,CACdX,IAAAA,IAAAA,IAdrB,KAAIY;AAAMZ,GAAAa,QAAAC,gBAAA,CAA6Bd,GAAAe,MAA7B,CACVlB,OAAA,CAAOG,GAAAe,MAAP,CACA,IAAA,CAAOH,YAaDI,aAAAA,CAAST,KAATS,CAVQV,EAURU,CAAiBL,CACrBX,KAAAQ,OAAAS,cAAA,CAA0BL,GAAA,CAAI,CAAJ,CAA1B,CAAkCI,YAAlC,CAA2C,CAA3C,CACAhB,KAAAQ,OAAAS,cAAA,CAA0BL,GAAA,CAAI,CAAJ,CAA1B,CAAkCI,YAAlC,CAA2C,CAA3C,CACAhB,KAAAQ,OAAAS,cAAA,CAA0BL,GAAA,CAAI,CAAJ,CAA1B,CAAkCI,YAAlC,CAA2C,CAA3C,CACAhB,KAAAQ,OAAAS,cAAA,CAA0BL,GAAA,CAAI,CAAJ,CAA1B,CAAkCI,YAAlC,CAA2C,EAA3C,CANiC,CAQ/BE,QAAAA,CAAMlB,IAAAQ,OAAAW,MAAA,CAAkB,CAAlB,CAAqBlB,KAAAI,OAArB,CACVL,KAAAQ,OAAA,CAAcR,IAAAQ,OAAAW,MAAA,CAAkBlB,KAAAI,OAAlB,CACd,OAAOV,IAAA,CAAIM,KAAJ,CAAWiB,QAAX,CAjBgC,CAZgE;",
"sources":["node_modules/browserify-aes/modes/ctr.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$browserify_aes$modes$ctr\"] = function(global,require,module,exports) {\nvar xor = require('buffer-xor')\nvar Buffer = require('safe-buffer').Buffer\nvar incr32 = require('../incr32')\n\nfunction getBlock (self) {\n  var out = self._cipher.encryptBlockRaw(self._prev)\n  incr32(self._prev)\n  return out\n}\n\nvar blockSize = 16\nexports.encrypt = function (self, chunk) {\n  var chunkNum = Math.ceil(chunk.length / blockSize)\n  var start = self._cache.length\n  self._cache = Buffer.concat([\n    self._cache,\n    Buffer.allocUnsafe(chunkNum * blockSize)\n  ])\n  for (var i = 0; i < chunkNum; i++) {\n    var out = getBlock(self)\n    var offset = start + i * blockSize\n    self._cache.writeUInt32BE(out[0], offset + 0)\n    self._cache.writeUInt32BE(out[1], offset + 4)\n    self._cache.writeUInt32BE(out[2], offset + 8)\n    self._cache.writeUInt32BE(out[3], offset + 12)\n  }\n  var pad = self._cache.slice(0, chunk.length)\n  self._cache = self._cache.slice(chunk.length)\n  return xor(chunk, pad)\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","xor","Buffer","incr32","encrypt","exports.encrypt","self","chunk","chunkNum","Math","ceil","length","blockSize","start","_cache","concat","allocUnsafe","i","out","_cipher","encryptBlockRaw","_prev","offset","writeUInt32BE","pad","slice"]
}
