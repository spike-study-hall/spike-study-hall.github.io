{
"version":3,
"file":"module$node_modules$negotiator$lib$encoding.js",
"lineCount":4,
"mappings":"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",
"sources":["node_modules/negotiator/lib/encoding.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$negotiator$lib$encoding\"] = function(global,require,module,exports) {\n/**\n * negotiator\n * Copyright(c) 2012 Isaac Z. Schlueter\n * Copyright(c) 2014 Federico Romero\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = preferredEncodings;\nmodule.exports.preferredEncodings = preferredEncodings;\n\n/**\n * Module variables.\n * @private\n */\n\nvar simpleEncodingRegExp = /^\\s*([^\\s;]+)\\s*(?:;(.*))?$/;\n\n/**\n * Parse the Accept-Encoding header.\n * @private\n */\n\nfunction parseAcceptEncoding(accept) {\n  var accepts = accept.split(',');\n  var hasIdentity = false;\n  var minQuality = 1;\n\n  for (var i = 0, j = 0; i < accepts.length; i++) {\n    var encoding = parseEncoding(accepts[i].trim(), i);\n\n    if (encoding) {\n      accepts[j++] = encoding;\n      hasIdentity = hasIdentity || specify('identity', encoding);\n      minQuality = Math.min(minQuality, encoding.q || 1);\n    }\n  }\n\n  if (!hasIdentity) {\n    /*\n     * If identity doesn't explicitly appear in the accept-encoding header,\n     * it's added to the list of acceptable encoding with the lowest q\n     */\n    accepts[j++] = {\n      encoding: 'identity',\n      q: minQuality,\n      i: i\n    };\n  }\n\n  // trim accepts\n  accepts.length = j;\n\n  return accepts;\n}\n\n/**\n * Parse an encoding from the Accept-Encoding header.\n * @private\n */\n\nfunction parseEncoding(str, i) {\n  var match = simpleEncodingRegExp.exec(str);\n  if (!match) return null;\n\n  var encoding = match[1];\n  var q = 1;\n  if (match[2]) {\n    var params = match[2].split(';');\n    for (var j = 0; j < params.length; j++) {\n      var p = params[j].trim().split('=');\n      if (p[0] === 'q') {\n        q = parseFloat(p[1]);\n        break;\n      }\n    }\n  }\n\n  return {\n    encoding: encoding,\n    q: q,\n    i: i\n  };\n}\n\n/**\n * Get the priority of an encoding.\n * @private\n */\n\nfunction getEncodingPriority(encoding, accepted, index) {\n  var priority = {o: -1, q: 0, s: 0};\n\n  for (var i = 0; i < accepted.length; i++) {\n    var spec = specify(encoding, accepted[i], index);\n\n    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {\n      priority = spec;\n    }\n  }\n\n  return priority;\n}\n\n/**\n * Get the specificity of the encoding.\n * @private\n */\n\nfunction specify(encoding, spec, index) {\n  var s = 0;\n  if(spec.encoding.toLowerCase() === encoding.toLowerCase()){\n    s |= 1;\n  } else if (spec.encoding !== '*' ) {\n    return null\n  }\n\n  return {\n    i: index,\n    o: spec.i,\n    q: spec.q,\n    s: s\n  }\n};\n\n/**\n * Get the preferred encodings from an Accept-Encoding header.\n * @public\n */\n\nfunction preferredEncodings(accept, provided) {\n  var accepts = parseAcceptEncoding(accept || '');\n\n  if (!provided) {\n    // sorted list of all encodings\n    return accepts\n      .filter(isQuality)\n      .sort(compareSpecs)\n      .map(getFullEncoding);\n  }\n\n  var priorities = provided.map(function getPriority(type, index) {\n    return getEncodingPriority(type, accepts, index);\n  });\n\n  // sorted list of accepted encodings\n  return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {\n    return provided[priorities.indexOf(priority)];\n  });\n}\n\n/**\n * Compare two specs.\n * @private\n */\n\nfunction compareSpecs(a, b) {\n  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;\n}\n\n/**\n * Get full encoding string.\n * @private\n */\n\nfunction getFullEncoding(spec) {\n  return spec.encoding;\n}\n\n/**\n * Check if a spec has any quality.\n * @private\n */\n\nfunction isQuality(spec) {\n  return spec.q > 0;\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","parseAcceptEncoding","accept","accepts","split","hasIdentity","minQuality","i","j","length","trim","match","simpleEncodingRegExp","exec","str","encoding","q","params","p","parseFloat","specify","Math","min","spec","index","s","toLowerCase","o","preferredEncodings","provided","filter","isQuality","sort","compareSpecs","map","getFullEncoding","priorities","getPriority","type","priority","getEncoding","indexOf","a","b"]
}
