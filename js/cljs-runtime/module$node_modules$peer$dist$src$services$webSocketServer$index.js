shadow$provide.module$node_modules$peer$dist$src$services$webSocketServer$index=function(global,require,module,exports){global=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{"default":mod}};Object.defineProperty(exports,"__esModule",{value:!0});var events_1=global(require("module$node_modules$events$events")),url_1=global(require("module$node_modules$url$url")),ws_1=global(require("module$node_modules$ws$index")),enums_1=require("module$node_modules$peer$dist$src$enums"),
client_1=require("module$node_modules$peer$dist$src$models$client");require=function($jscomp$destructuring$var0){var server=$jscomp$destructuring$var0.server,realm=$jscomp$destructuring$var0.realm;$jscomp$destructuring$var0=$jscomp$destructuring$var0.config;var $jscomp$super$this=events_1.default.call(this)||this;$jscomp$super$this.setMaxListeners(0);$jscomp$super$this.realm=realm;$jscomp$super$this.config=$jscomp$destructuring$var0;realm=$jscomp$super$this.config.path;$jscomp$super$this.path=""+
realm+(realm.endsWith("/")?"":"/")+"peerjs";$jscomp$super$this.socketServer=new ws_1.default.Server({path:$jscomp$super$this.path,server:server});$jscomp$super$this.socketServer.on("connection",function(socket,req){return $jscomp$super$this._onSocketConnection(socket,req)});$jscomp$super$this.socketServer.on("error",function(error){return $jscomp$super$this._onSocketError(error)});return $jscomp$super$this};$jscomp.inherits(require,events_1.default);require.prototype._onSocketConnection=function(socket,
req){req=url_1.default.parse(req.url,!0);var $jscomp$destructuring$var3=void 0===req.query?{}:req.query;req=$jscomp$destructuring$var3.id;var token=$jscomp$destructuring$var3.token;$jscomp$destructuring$var3=$jscomp$destructuring$var3.key;if(!req||!token||!$jscomp$destructuring$var3)return this._sendErrorAndClose(socket,enums_1.Errors.INVALID_WS_PARAMETERS);if($jscomp$destructuring$var3!==this.config.key)return this._sendErrorAndClose(socket,enums_1.Errors.INVALID_KEY);if($jscomp$destructuring$var3=
this.realm.getClientById(req))return token!==$jscomp$destructuring$var3.getToken()?(socket.send(JSON.stringify({type:enums_1.MessageType.ID_TAKEN,payload:{msg:"ID is taken"}})),socket.close()):this._configureWS(socket,$jscomp$destructuring$var3);this._registerClient({socket:socket,id:req,token:token})};require.prototype._onSocketError=function(error){this.emit("error",error)};require.prototype._registerClient=function($jscomp$destructuring$var4){var socket=$jscomp$destructuring$var4.socket,id=$jscomp$destructuring$var4.id;
$jscomp$destructuring$var4=$jscomp$destructuring$var4.token;if(this.realm.getClientsIds().length>=this.config.concurrent_limit)return this._sendErrorAndClose(socket,enums_1.Errors.CONNECTION_LIMIT_EXCEED);$jscomp$destructuring$var4=new client_1.Client({id:id,token:$jscomp$destructuring$var4});this.realm.setClient($jscomp$destructuring$var4,id);socket.send(JSON.stringify({type:enums_1.MessageType.OPEN}));this._configureWS(socket,$jscomp$destructuring$var4)};require.prototype._configureWS=function(socket,
client){var $jscomp$this=this;client.setSocket(socket);socket.on("close",function(){client.getSocket()===socket&&($jscomp$this.realm.removeClientById(client.getId()),$jscomp$this.emit("close",client))});socket.on("message",function(data){try{var message=JSON.parse(data);message.src=client.getId();$jscomp$this.emit("message",client,message)}catch(e){$jscomp$this.emit("error",e)}});this.emit("connection",client)};require.prototype._sendErrorAndClose=function(socket,msg){socket.send(JSON.stringify({type:enums_1.MessageType.ERROR,
payload:{msg:msg}}));socket.close()};exports.WebSocketServer=require}
//# sourceMappingURL=module$node_modules$peer$dist$src$services$webSocketServer$index.js.map
