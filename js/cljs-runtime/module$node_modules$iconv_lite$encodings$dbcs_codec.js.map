{
"version":3,
"file":"module$node_modules$iconv_lite$encodings$dbcs_codec.js",
"lineCount":20,
"mappings":"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",
"sources":["node_modules/iconv-lite/encodings/dbcs-codec.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$iconv_lite$encodings$dbcs_codec\"] = function(global,require,module,exports) {\n\"use strict\";\nvar Buffer = require(\"safer-buffer\").Buffer;\n\n// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.\n// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.\n// To save memory and loading time, we read table files only when requested.\n\nexports._dbcs = DBCSCodec;\n\nvar UNASSIGNED = -1,\n    GB18030_CODE = -2,\n    SEQ_START  = -10,\n    NODE_START = -1000,\n    UNASSIGNED_NODE = new Array(0x100),\n    DEF_CHAR = -1;\n\nfor (var i = 0; i < 0x100; i++)\n    UNASSIGNED_NODE[i] = UNASSIGNED;\n\n\n// Class DBCSCodec reads and initializes mapping tables.\nfunction DBCSCodec(codecOptions, iconv) {\n    this.encodingName = codecOptions.encodingName;\n    if (!codecOptions)\n        throw new Error(\"DBCS codec is called without the data.\")\n    if (!codecOptions.table)\n        throw new Error(\"Encoding '\" + this.encodingName + \"' has no data.\");\n\n    // Load tables.\n    var mappingTable = codecOptions.table();\n\n\n    // Decode tables: MBCS -> Unicode.\n\n    // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.\n    // Trie root is decodeTables[0].\n    // Values: >=  0 -> unicode character code. can be > 0xFFFF\n    //         == UNASSIGNED -> unknown/unassigned sequence.\n    //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.\n    //         <= NODE_START -> index of the next node in our trie to process next byte.\n    //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.\n    this.decodeTables = [];\n    this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.\n\n    // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. \n    this.decodeTableSeq = [];\n\n    // Actual mapping tables consist of chunks. Use them to fill up decode tables.\n    for (var i = 0; i < mappingTable.length; i++)\n        this._addDecodeChunk(mappingTable[i]);\n\n    this.defaultCharUnicode = iconv.defaultCharUnicode;\n\n    \n    // Encode tables: Unicode -> DBCS.\n\n    // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.\n    // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.\n    // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).\n    //         == UNASSIGNED -> no conversion found. Output a default char.\n    //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.\n    this.encodeTable = [];\n    \n    // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of\n    // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key\n    // means end of sequence (needed when one sequence is a strict subsequence of another).\n    // Objects are kept separately from encodeTable to increase performance.\n    this.encodeTableSeq = [];\n\n    // Some chars can be decoded, but need not be encoded.\n    var skipEncodeChars = {};\n    if (codecOptions.encodeSkipVals)\n        for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {\n            var val = codecOptions.encodeSkipVals[i];\n            if (typeof val === 'number')\n                skipEncodeChars[val] = true;\n            else\n                for (var j = val.from; j <= val.to; j++)\n                    skipEncodeChars[j] = true;\n        }\n        \n    // Use decode trie to recursively fill out encode tables.\n    this._fillEncodeTable(0, 0, skipEncodeChars);\n\n    // Add more encoding pairs when needed.\n    if (codecOptions.encodeAdd) {\n        for (var uChar in codecOptions.encodeAdd)\n            if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))\n                this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);\n    }\n\n    this.defCharSB  = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];\n    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];\n    if (this.defCharSB === UNASSIGNED) this.defCharSB = \"?\".charCodeAt(0);\n\n\n    // Load & create GB18030 tables when needed.\n    if (typeof codecOptions.gb18030 === 'function') {\n        this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.\n\n        // Add GB18030 decode tables.\n        var thirdByteNodeIdx = this.decodeTables.length;\n        var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);\n\n        var fourthByteNodeIdx = this.decodeTables.length;\n        var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);\n\n        for (var i = 0x81; i <= 0xFE; i++) {\n            var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];\n            var secondByteNode = this.decodeTables[secondByteNodeIdx];\n            for (var j = 0x30; j <= 0x39; j++)\n                secondByteNode[j] = NODE_START - thirdByteNodeIdx;\n        }\n        for (var i = 0x81; i <= 0xFE; i++)\n            thirdByteNode[i] = NODE_START - fourthByteNodeIdx;\n        for (var i = 0x30; i <= 0x39; i++)\n            fourthByteNode[i] = GB18030_CODE\n    }        \n}\n\nDBCSCodec.prototype.encoder = DBCSEncoder;\nDBCSCodec.prototype.decoder = DBCSDecoder;\n\n// Decoder helpers\nDBCSCodec.prototype._getDecodeTrieNode = function(addr) {\n    var bytes = [];\n    for (; addr > 0; addr >>= 8)\n        bytes.push(addr & 0xFF);\n    if (bytes.length == 0)\n        bytes.push(0);\n\n    var node = this.decodeTables[0];\n    for (var i = bytes.length-1; i > 0; i--) { // Traverse nodes deeper into the trie.\n        var val = node[bytes[i]];\n\n        if (val == UNASSIGNED) { // Create new node.\n            node[bytes[i]] = NODE_START - this.decodeTables.length;\n            this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));\n        }\n        else if (val <= NODE_START) { // Existing node.\n            node = this.decodeTables[NODE_START - val];\n        }\n        else\n            throw new Error(\"Overwrite byte in \" + this.encodingName + \", addr: \" + addr.toString(16));\n    }\n    return node;\n}\n\n\nDBCSCodec.prototype._addDecodeChunk = function(chunk) {\n    // First element of chunk is the hex mbcs code where we start.\n    var curAddr = parseInt(chunk[0], 16);\n\n    // Choose the decoding node where we'll write our chars.\n    var writeTable = this._getDecodeTrieNode(curAddr);\n    curAddr = curAddr & 0xFF;\n\n    // Write all other elements of the chunk to the table.\n    for (var k = 1; k < chunk.length; k++) {\n        var part = chunk[k];\n        if (typeof part === \"string\") { // String, write as-is.\n            for (var l = 0; l < part.length;) {\n                var code = part.charCodeAt(l++);\n                if (0xD800 <= code && code < 0xDC00) { // Decode surrogate\n                    var codeTrail = part.charCodeAt(l++);\n                    if (0xDC00 <= codeTrail && codeTrail < 0xE000)\n                        writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);\n                    else\n                        throw new Error(\"Incorrect surrogate pair in \"  + this.encodingName + \" at chunk \" + chunk[0]);\n                }\n                else if (0x0FF0 < code && code <= 0x0FFF) { // Character sequence (our own encoding used)\n                    var len = 0xFFF - code + 2;\n                    var seq = [];\n                    for (var m = 0; m < len; m++)\n                        seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.\n\n                    writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;\n                    this.decodeTableSeq.push(seq);\n                }\n                else\n                    writeTable[curAddr++] = code; // Basic char\n            }\n        } \n        else if (typeof part === \"number\") { // Integer, meaning increasing sequence starting with prev character.\n            var charCode = writeTable[curAddr - 1] + 1;\n            for (var l = 0; l < part; l++)\n                writeTable[curAddr++] = charCode++;\n        }\n        else\n            throw new Error(\"Incorrect type '\" + typeof part + \"' given in \"  + this.encodingName + \" at chunk \" + chunk[0]);\n    }\n    if (curAddr > 0xFF)\n        throw new Error(\"Incorrect chunk in \"  + this.encodingName + \" at addr \" + chunk[0] + \": too long\" + curAddr);\n}\n\n// Encoder helpers\nDBCSCodec.prototype._getEncodeBucket = function(uCode) {\n    var high = uCode >> 8; // This could be > 0xFF because of astral characters.\n    if (this.encodeTable[high] === undefined)\n        this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.\n    return this.encodeTable[high];\n}\n\nDBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {\n    var bucket = this._getEncodeBucket(uCode);\n    var low = uCode & 0xFF;\n    if (bucket[low] <= SEQ_START)\n        this.encodeTableSeq[SEQ_START-bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.\n    else if (bucket[low] == UNASSIGNED)\n        bucket[low] = dbcsCode;\n}\n\nDBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {\n    \n    // Get the root of character tree according to first character of the sequence.\n    var uCode = seq[0];\n    var bucket = this._getEncodeBucket(uCode);\n    var low = uCode & 0xFF;\n\n    var node;\n    if (bucket[low] <= SEQ_START) {\n        // There's already a sequence with  - use it.\n        node = this.encodeTableSeq[SEQ_START-bucket[low]];\n    }\n    else {\n        // There was no sequence object - allocate a new one.\n        node = {};\n        if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.\n        bucket[low] = SEQ_START - this.encodeTableSeq.length;\n        this.encodeTableSeq.push(node);\n    }\n\n    // Traverse the character tree, allocating new nodes as needed.\n    for (var j = 1; j < seq.length-1; j++) {\n        var oldVal = node[uCode];\n        if (typeof oldVal === 'object')\n            node = oldVal;\n        else {\n            node = node[uCode] = {}\n            if (oldVal !== undefined)\n                node[DEF_CHAR] = oldVal\n        }\n    }\n\n    // Set the leaf to given dbcsCode.\n    uCode = seq[seq.length-1];\n    node[uCode] = dbcsCode;\n}\n\nDBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {\n    var node = this.decodeTables[nodeIdx];\n    for (var i = 0; i < 0x100; i++) {\n        var uCode = node[i];\n        var mbCode = prefix + i;\n        if (skipEncodeChars[mbCode])\n            continue;\n\n        if (uCode >= 0)\n            this._setEncodeChar(uCode, mbCode);\n        else if (uCode <= NODE_START)\n            this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);\n        else if (uCode <= SEQ_START)\n            this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);\n    }\n}\n\n\n\n// == Encoder ==================================================================\n\nfunction DBCSEncoder(options, codec) {\n    // Encoder state\n    this.leadSurrogate = -1;\n    this.seqObj = undefined;\n    \n    // Static data\n    this.encodeTable = codec.encodeTable;\n    this.encodeTableSeq = codec.encodeTableSeq;\n    this.defaultCharSingleByte = codec.defCharSB;\n    this.gb18030 = codec.gb18030;\n}\n\nDBCSEncoder.prototype.write = function(str) {\n    var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),\n        leadSurrogate = this.leadSurrogate,\n        seqObj = this.seqObj, nextChar = -1,\n        i = 0, j = 0;\n\n    while (true) {\n        // 0. Get next character.\n        if (nextChar === -1) {\n            if (i == str.length) break;\n            var uCode = str.charCodeAt(i++);\n        }\n        else {\n            var uCode = nextChar;\n            nextChar = -1;    \n        }\n\n        // 1. Handle surrogates.\n        if (0xD800 <= uCode && uCode < 0xE000) { // Char is one of surrogates.\n            if (uCode < 0xDC00) { // We've got lead surrogate.\n                if (leadSurrogate === -1) {\n                    leadSurrogate = uCode;\n                    continue;\n                } else {\n                    leadSurrogate = uCode;\n                    // Double lead surrogate found.\n                    uCode = UNASSIGNED;\n                }\n            } else { // We've got trail surrogate.\n                if (leadSurrogate !== -1) {\n                    uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);\n                    leadSurrogate = -1;\n                } else {\n                    // Incomplete surrogate pair - only trail surrogate found.\n                    uCode = UNASSIGNED;\n                }\n                \n            }\n        }\n        else if (leadSurrogate !== -1) {\n            // Incomplete surrogate pair - only lead surrogate found.\n            nextChar = uCode; uCode = UNASSIGNED; // Write an error, then current char.\n            leadSurrogate = -1;\n        }\n\n        // 2. Convert uCode character.\n        var dbcsCode = UNASSIGNED;\n        if (seqObj !== undefined && uCode != UNASSIGNED) { // We are in the middle of the sequence\n            var resCode = seqObj[uCode];\n            if (typeof resCode === 'object') { // Sequence continues.\n                seqObj = resCode;\n                continue;\n\n            } else if (typeof resCode == 'number') { // Sequence finished. Write it.\n                dbcsCode = resCode;\n\n            } else if (resCode == undefined) { // Current character is not part of the sequence.\n\n                // Try default character for this sequence\n                resCode = seqObj[DEF_CHAR];\n                if (resCode !== undefined) {\n                    dbcsCode = resCode; // Found. Write it.\n                    nextChar = uCode; // Current character will be written too in the next iteration.\n\n                } else {\n                    // TODO: What if we have no default? (resCode == undefined)\n                    // Then, we should write first char of the sequence as-is and try the rest recursively.\n                    // Didn't do it for now because no encoding has this situation yet.\n                    // Currently, just skip the sequence and write current char.\n                }\n            }\n            seqObj = undefined;\n        }\n        else if (uCode >= 0) {  // Regular character\n            var subtable = this.encodeTable[uCode >> 8];\n            if (subtable !== undefined)\n                dbcsCode = subtable[uCode & 0xFF];\n            \n            if (dbcsCode <= SEQ_START) { // Sequence start\n                seqObj = this.encodeTableSeq[SEQ_START-dbcsCode];\n                continue;\n            }\n\n            if (dbcsCode == UNASSIGNED && this.gb18030) {\n                // Use GB18030 algorithm to find character(s) to write.\n                var idx = findIdx(this.gb18030.uChars, uCode);\n                if (idx != -1) {\n                    var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);\n                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600); dbcsCode = dbcsCode % 12600;\n                    newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260); dbcsCode = dbcsCode % 1260;\n                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10); dbcsCode = dbcsCode % 10;\n                    newBuf[j++] = 0x30 + dbcsCode;\n                    continue;\n                }\n            }\n        }\n\n        // 3. Write dbcsCode character.\n        if (dbcsCode === UNASSIGNED)\n            dbcsCode = this.defaultCharSingleByte;\n        \n        if (dbcsCode < 0x100) {\n            newBuf[j++] = dbcsCode;\n        }\n        else if (dbcsCode < 0x10000) {\n            newBuf[j++] = dbcsCode >> 8;   // high byte\n            newBuf[j++] = dbcsCode & 0xFF; // low byte\n        }\n        else {\n            newBuf[j++] = dbcsCode >> 16;\n            newBuf[j++] = (dbcsCode >> 8) & 0xFF;\n            newBuf[j++] = dbcsCode & 0xFF;\n        }\n    }\n\n    this.seqObj = seqObj;\n    this.leadSurrogate = leadSurrogate;\n    return newBuf.slice(0, j);\n}\n\nDBCSEncoder.prototype.end = function() {\n    if (this.leadSurrogate === -1 && this.seqObj === undefined)\n        return; // All clean. Most often case.\n\n    var newBuf = Buffer.alloc(10), j = 0;\n\n    if (this.seqObj) { // We're in the sequence.\n        var dbcsCode = this.seqObj[DEF_CHAR];\n        if (dbcsCode !== undefined) { // Write beginning of the sequence.\n            if (dbcsCode < 0x100) {\n                newBuf[j++] = dbcsCode;\n            }\n            else {\n                newBuf[j++] = dbcsCode >> 8;   // high byte\n                newBuf[j++] = dbcsCode & 0xFF; // low byte\n            }\n        } else {\n            // See todo above.\n        }\n        this.seqObj = undefined;\n    }\n\n    if (this.leadSurrogate !== -1) {\n        // Incomplete surrogate pair - only lead surrogate found.\n        newBuf[j++] = this.defaultCharSingleByte;\n        this.leadSurrogate = -1;\n    }\n    \n    return newBuf.slice(0, j);\n}\n\n// Export for testing\nDBCSEncoder.prototype.findIdx = findIdx;\n\n\n// == Decoder ==================================================================\n\nfunction DBCSDecoder(options, codec) {\n    // Decoder state\n    this.nodeIdx = 0;\n    this.prevBuf = Buffer.alloc(0);\n\n    // Static data\n    this.decodeTables = codec.decodeTables;\n    this.decodeTableSeq = codec.decodeTableSeq;\n    this.defaultCharUnicode = codec.defaultCharUnicode;\n    this.gb18030 = codec.gb18030;\n}\n\nDBCSDecoder.prototype.write = function(buf) {\n    var newBuf = Buffer.alloc(buf.length*2),\n        nodeIdx = this.nodeIdx, \n        prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length,\n        seqStart = -this.prevBuf.length, // idx of the start of current parsed sequence.\n        uCode;\n\n    if (prevBufOffset > 0) // Make prev buf overlap a little to make it easier to slice later.\n        prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);\n    \n    for (var i = 0, j = 0; i < buf.length; i++) {\n        var curByte = (i >= 0) ? buf[i] : prevBuf[i + prevBufOffset];\n\n        // Lookup in current trie node.\n        var uCode = this.decodeTables[nodeIdx][curByte];\n\n        if (uCode >= 0) { \n            // Normal character, just use it.\n        }\n        else if (uCode === UNASSIGNED) { // Unknown char.\n            // TODO: Callback with seq.\n            //var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);\n            i = seqStart; // Try to parse again, after skipping first byte of the sequence ('i' will be incremented by 'for' cycle).\n            uCode = this.defaultCharUnicode.charCodeAt(0);\n        }\n        else if (uCode === GB18030_CODE) {\n            var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);\n            var ptr = (curSeq[0]-0x81)*12600 + (curSeq[1]-0x30)*1260 + (curSeq[2]-0x81)*10 + (curSeq[3]-0x30);\n            var idx = findIdx(this.gb18030.gbChars, ptr);\n            uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];\n        }\n        else if (uCode <= NODE_START) { // Go to next trie node.\n            nodeIdx = NODE_START - uCode;\n            continue;\n        }\n        else if (uCode <= SEQ_START) { // Output a sequence of chars.\n            var seq = this.decodeTableSeq[SEQ_START - uCode];\n            for (var k = 0; k < seq.length - 1; k++) {\n                uCode = seq[k];\n                newBuf[j++] = uCode & 0xFF;\n                newBuf[j++] = uCode >> 8;\n            }\n            uCode = seq[seq.length-1];\n        }\n        else\n            throw new Error(\"iconv-lite internal error: invalid decoding table value \" + uCode + \" at \" + nodeIdx + \"/\" + curByte);\n\n        // Write the character to buffer, handling higher planes using surrogate pair.\n        if (uCode > 0xFFFF) { \n            uCode -= 0x10000;\n            var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);\n            newBuf[j++] = uCodeLead & 0xFF;\n            newBuf[j++] = uCodeLead >> 8;\n\n            uCode = 0xDC00 + uCode % 0x400;\n        }\n        newBuf[j++] = uCode & 0xFF;\n        newBuf[j++] = uCode >> 8;\n\n        // Reset trie node.\n        nodeIdx = 0; seqStart = i+1;\n    }\n\n    this.nodeIdx = nodeIdx;\n    this.prevBuf = (seqStart >= 0) ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);\n    return newBuf.slice(0, j).toString('ucs2');\n}\n\nDBCSDecoder.prototype.end = function() {\n    var ret = '';\n\n    // Try to parse all remaining chars.\n    while (this.prevBuf.length > 0) {\n        // Skip 1 character in the buffer.\n        ret += this.defaultCharUnicode;\n        var buf = this.prevBuf.slice(1);\n\n        // Parse remaining as usual.\n        this.prevBuf = Buffer.alloc(0);\n        this.nodeIdx = 0;\n        if (buf.length > 0)\n            ret += this.write(buf);\n    }\n\n    this.nodeIdx = 0;\n    return ret;\n}\n\n// Binary search for GB18030. Returns largest i such that table[i] <= val.\nfunction findIdx(table, val) {\n    if (table[0] > val)\n        return -1;\n\n    var l = 0, r = table.length;\n    while (l < r-1) { // always table[l] <= val < table[r]\n        var mid = l + Math.floor((r-l+1)/2);\n        if (table[mid] <= val)\n            l = mid;\n        else\n            r = mid;\n    }\n    return l;\n}\n\n\n};"],
"names":["shadow$provide","global","require","module","exports","DBCSCodec","codecOptions","iconv","encodingName","Error","table","mappingTable","decodeTables","UNASSIGNED_NODE","slice","decodeTableSeq","i","length","_addDecodeChunk","defaultCharUnicode","encodeTable","encodeTableSeq","skipEncodeChars","encodeSkipVals","val","j","from","to","_fillEncodeTable","encodeAdd","uChar","Object","prototype","hasOwnProperty","call","_setEncodeChar","charCodeAt","defCharSB","defaultCharSingleByte","UNASSIGNED","gb18030","thirdByteNodeIdx","thirdByteNode","fourthByteNodeIdx","fourthByteNode","secondByteNode","NODE_START","GB18030_CODE","DBCSEncoder","options","codec","leadSurrogate","seqObj","undefined","DBCSDecoder","nodeIdx","prevBuf","Buffer","alloc","findIdx","l","r","mid","Math","floor","_dbcs","Array","encoder","decoder","_getDecodeTrieNode","DBCSCodec.prototype._getDecodeTrieNode","addr","bytes","push","node","toString","DBCSCodec.prototype._addDecodeChunk","chunk","curAddr","parseInt","writeTable","k","part","code","codeTrail","len","seq","m","SEQ_START","charCode","_getEncodeBucket","DBCSCodec.prototype._getEncodeBucket","uCode","high","DBCSCodec.prototype._setEncodeChar","dbcsCode","bucket","low","DEF_CHAR","_setEncodeSequence","DBCSCodec.prototype._setEncodeSequence","oldVal","DBCSCodec.prototype._fillEncodeTable","prefix","mbCode","write","DBCSEncoder.prototype.write","str","newBuf","nextChar","resCode","subtable","idx","uChars","gbChars","end","DBCSEncoder.prototype.end","DBCSDecoder.prototype.write","buf","prevBufOffset","seqStart","concat","curByte","curSeq","ptr","uCodeLead","DBCSDecoder.prototype.end","ret"]
}
