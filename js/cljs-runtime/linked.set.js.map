{"version":3,"sources":["linked/set.cljc"],"mappings":"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","names":["self__","args58859","cljs.core/aclone","this__4374__auto__","writer__4375__auto__","opt__4376__auto__","cljs.core/-write","linked.set/LinkedSet","linked.set/->LinkedSet","linked-map","this","clojure.string.join.cljs$core$IFn$_invoke$arity$2","cljs.core.map.cljs$core$IFn$_invoke$arity$2","cljs.core/str","other","_","coll","meta","cljs.core/with-meta","cljs.core/meta","o","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","linked.set/empty-linked-set","cljs.core/set?","cljs.core/count","p1__58858#","cljs.core/every?","cljs.core/contains?","cljs.core/hash","cljs.core.into.cljs$core$IFn$_invoke$arity$2","temp__5735__auto__","s","cljs.core/seq","cljs.core/key","cljs.core/rseq","cljs.core/-count","v","not-found","cljs.core/-contains-key?","cljs.core/-dissoc","k","writer","opts","linked.map/empty-linked-map","linked.set/->linked-set","cljs.core.partial.cljs$core$IFn$_invoke$arity$2","cljs.core/into","cljs.reader/register-tag-parser!"],"sourcesContent":["(ns linked.set\n  (:require [linked.map :refer [empty-linked-map]]\n            [clojure.string :as string]\n    #?(:cljs [cljs.reader :as reader]))\n  #?(:clj\n     (:import (clojure.lang Counted\n                            IObj\n                            IFn\n                            IHashEq\n                            ILookup\n                            IPersistentCollection\n                            IPersistentSet\n                            IPersistentVector\n                            Reversible\n                            Seqable\n                            SeqIterator)\n              (java.util Set)\n              (java.lang Iterable))))\n\n(declare empty-linked-set)\n\n(deftype LinkedSet [linked-map]\n  #?@(:clj\n      [IPersistentSet\n       (disjoin [_ k]\n         (LinkedSet. (dissoc linked-map k)))\n       (contains [_ k]\n         (contains? linked-map k))\n       (get [this k]\n         (when (.contains this k) k))\n\n       Set\n       (size [this]\n         (.count this))\n\n       Iterable\n       (iterator [this]\n         (SeqIterator. (.seq this)))\n\n       Counted\n\n       IPersistentCollection\n       (count [_]\n         (count linked-map))\n       (cons [this o]\n         (if (contains? linked-map o)\n           this\n           (LinkedSet. (assoc linked-map o nil))))\n       (empty [_]\n         empty-linked-set)\n       (equiv [this other]\n         (or (identical? this other)\n             (and (instance? Set other)\n                  (let [^Set s other]\n                    (and (= (.size this) (.size s))\n                         (every? #(.contains s %) (.seq this)))))))\n       Seqable\n       (seq [_]\n         (when-let [s (seq linked-map)] (map key s)))\n\n       Reversible\n       (rseq [_]\n         (when-let [s (rseq linked-map)] (map key s)))\n\n       IFn\n       (invoke [this k]\n         (get this k))\n\n       IObj\n       (meta [this]\n         (.meta ^IObj linked-map))\n       (withMeta [this m]\n         (LinkedSet. (.withMeta ^IObj linked-map m)))\n\n       IHashEq\n       (hasheq [this] (.hasheq ^IHashEq (into #{} this)))\n\n       Object\n       (toString [this]\n         (str \"[\" (string/join \" \" (map str this)) \"]\"))\n       (hashCode [this]\n         (.hashCode ^Object (into #{} this)))\n       (equals [this other]\n         (.equiv this other))]\n      :cljs\n      [Object\n       (toString [this]\n                 (str \"[\" (string/join \" \" (map str this)) \"]\"))\n       (equiv [this other]\n              (-equiv this other))\n\n       ICloneable\n       (-clone [_] (LinkedSet. linked-map))\n\n       IWithMeta\n       (-with-meta [coll meta] (LinkedSet. (with-meta linked-map meta)))\n\n       IMeta\n       (-meta [coll] (meta linked-map))\n\n       ICollection\n       (-conj [coll o]\n              (LinkedSet. (assoc linked-map o nil)))\n\n       IEmptyableCollection\n       (-empty [coll] (with-meta empty-linked-set meta))\n\n       IEquiv\n       (-equiv [coll other]\n               (and\n                 (set? other)\n                 (== (count coll) (count other))\n                 (every? #(contains? coll %)\n                         other)))\n\n       IHash\n       (-hash [coll] (hash (into #{} coll)))\n\n       ISeqable\n       (-seq [coll] (when-let [s (seq linked-map)] (map key s)))\n\n       IReversible\n       (-rseq [coll] (when-let [s (rseq linked-map)] (map key s)))\n\n       ISequential\n\n       ICounted\n       (-count [coll] (-count linked-map))\n\n       ILookup\n       (-lookup [coll v]\n                (-lookup coll v nil))\n       (-lookup [coll v not-found]\n                (if (-contains-key? linked-map v)\n                  v\n                  not-found))\n\n       ISet\n       (-disjoin [coll v]\n                 (LinkedSet. (-dissoc linked-map v)))\n\n       IFn\n       (-invoke [coll k]\n                (-lookup coll k))\n       (-invoke [coll k not-found]\n                (-lookup coll k not-found))\n\n       ;; IEditableCollection\n\n       IPrintWithWriter\n       (-pr-writer [coll writer opts]\n                   (-write writer (str \"#linked/set \" (into [] coll))))]))\n\n#?(:clj\n   (defmethod print-method LinkedSet [o ^java.io.Writer w]\n     (.write w \"#linked/set \")\n     (print-method (into [] o) w)))\n\n(def ^{:tag LinkedSet} empty-linked-set\n  (LinkedSet. empty-linked-map))\n\n(def ->linked-set (partial into empty-linked-set))\n\n#?(:cljs (reader/register-tag-parser! 'linked/set ->linked-set))\n"]}