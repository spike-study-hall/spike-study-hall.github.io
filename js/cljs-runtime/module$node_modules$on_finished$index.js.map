{
"version":3,
"file":"module$node_modules$on_finished$index.js",
"lineCount":4,
"mappings":"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",
"sources":["node_modules/on-finished/index.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$on_finished$index\"] = function(global,require,module,exports) {\nvar process = require('process');\n/*!\n * on-finished\n * Copyright(c) 2013 Jonathan Ong\n * Copyright(c) 2014 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = onFinished\nmodule.exports.isFinished = isFinished\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar first = require('ee-first')\n\n/**\n * Variables.\n * @private\n */\n\n/* istanbul ignore next */\nvar defer = typeof setImmediate === 'function'\n  ? setImmediate\n  : function(fn){ process.nextTick(fn.bind.apply(fn, arguments)) }\n\n/**\n * Invoke callback when the response has finished, useful for\n * cleaning up resources afterwards.\n *\n * @param {object} msg\n * @param {function} listener\n * @return {object}\n * @public\n */\n\nfunction onFinished(msg, listener) {\n  if (isFinished(msg) !== false) {\n    defer(listener, null, msg)\n    return msg\n  }\n\n  // attach the listener to the message\n  attachListener(msg, listener)\n\n  return msg\n}\n\n/**\n * Determine if message is already finished.\n *\n * @param {object} msg\n * @return {boolean}\n * @public\n */\n\nfunction isFinished(msg) {\n  var socket = msg.socket\n\n  if (typeof msg.finished === 'boolean') {\n    // OutgoingMessage\n    return Boolean(msg.finished || (socket && !socket.writable))\n  }\n\n  if (typeof msg.complete === 'boolean') {\n    // IncomingMessage\n    return Boolean(msg.upgrade || !socket || !socket.readable || (msg.complete && !msg.readable))\n  }\n\n  // don't know\n  return undefined\n}\n\n/**\n * Attach a finished listener to the message.\n *\n * @param {object} msg\n * @param {function} callback\n * @private\n */\n\nfunction attachFinishedListener(msg, callback) {\n  var eeMsg\n  var eeSocket\n  var finished = false\n\n  function onFinish(error) {\n    eeMsg.cancel()\n    eeSocket.cancel()\n\n    finished = true\n    callback(error)\n  }\n\n  // finished on first message event\n  eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish)\n\n  function onSocket(socket) {\n    // remove listener\n    msg.removeListener('socket', onSocket)\n\n    if (finished) return\n    if (eeMsg !== eeSocket) return\n\n    // finished on first socket event\n    eeSocket = first([[socket, 'error', 'close']], onFinish)\n  }\n\n  if (msg.socket) {\n    // socket already assigned\n    onSocket(msg.socket)\n    return\n  }\n\n  // wait for socket to be assigned\n  msg.on('socket', onSocket)\n\n  if (msg.socket === undefined) {\n    // node.js 0.8 patch\n    patchAssignSocket(msg, onSocket)\n  }\n}\n\n/**\n * Attach the listener to the message.\n *\n * @param {object} msg\n * @return {function}\n * @private\n */\n\nfunction attachListener(msg, listener) {\n  var attached = msg.__onFinished\n\n  // create a private single listener with queue\n  if (!attached || !attached.queue) {\n    attached = msg.__onFinished = createListener(msg)\n    attachFinishedListener(msg, attached)\n  }\n\n  attached.queue.push(listener)\n}\n\n/**\n * Create listener on message.\n *\n * @param {object} msg\n * @return {function}\n * @private\n */\n\nfunction createListener(msg) {\n  function listener(err) {\n    if (msg.__onFinished === listener) msg.__onFinished = null\n    if (!listener.queue) return\n\n    var queue = listener.queue\n    listener.queue = null\n\n    for (var i = 0; i < queue.length; i++) {\n      queue[i](err, msg)\n    }\n  }\n\n  listener.queue = []\n\n  return listener\n}\n\n/**\n * Patch ServerResponse.prototype.assignSocket for node.js 0.8.\n *\n * @param {ServerResponse} res\n * @param {function} callback\n * @private\n */\n\nfunction patchAssignSocket(res, callback) {\n  var assignSocket = res.assignSocket\n\n  if (typeof assignSocket !== 'function') return\n\n  // res.on('socket', callback) is broken in 0.8\n  res.assignSocket = function _assignSocket(socket) {\n    assignSocket.call(this, socket)\n    callback(socket)\n  }\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","isFinished","msg","socket","finished","writable","complete","upgrade","readable","attachFinishedListener","callback","onFinish","error","eeMsg","cancel","eeSocket","onSocket","removeListener","first","on","undefined","patchAssignSocket","createListener","listener","err","__onFinished","queue","i","length","res","assignSocket","res.assignSocket","call","process","onFinished","defer","attached","push","setImmediate","fn","nextTick","bind","apply","arguments"]
}
